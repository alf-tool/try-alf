<div class="blog-post-date">2013, October 21</div>

<h1>Relations as First-Class Citizen - A Paradigm Shift for Software/Database Collaboration</h1>

<p>I&#39;m happy to announce that Alf v0.15.0 has just been released and with it,
this web site! I&#39;ve been hacking on Alf on my free time for about two years
now; I think it was time to share it in a slightly more official way that an
(almost invisible) <a href="https://github.com/alf-tool">open-source project</a> on
github.</p>

<p>Alf is a modern, powerful implementation of relational algebra. It brings
relational algebra where you don&#39;t necessarily expect it: in shell, in
scripting and for building complex software (in ruby so far). Alf has an
impressive list of features. Among them, it allows you to:</p>

<ul>
<li>Query .json, .csv, .yaml files and convert from one format to the other with
ease,</li>
<li>Query SQL databases with a sounder and more powerful query language than SQL
itself,</li>
<li>Export structured and so-called &quot;semi-structured&quot; query results in various
exchange formats,</li>
<li>Query multiple data sources as if they were one and only one database,</li>
<li>Create database <em>viewpoints</em>, to provide your users with a true database
interface while keeping them away from data they may not have access to,</li>
<li>Define your own high-level, domain-specific, relational operators.</li>
</ul>

<p>Alf is very young and not all of the advanced features are stable and/or
documented. I plan to spend some time in the next weeks and months to work on
them, so stay tuned. In the mean time, you can play with Alf on this website,
install <a href="https://rubygems.org/gems/alf">alf 0.15.0</a> and start playing with it
on your own datasets and databases. I&#39;ll come with advanced material on this
blog as soon as possible, I promise. The rest of this post explains the
context of this work and why it exists in the first place.</p>

<h2>Yet another database connectivity library?</h2>

<p>We already have <a href="https://github.com/rails/arel">ARel</a>,
<a href="http://sequel.rubyforge.org/">Sequel</a>,
<a href="http://www.sqlalchemy.org/">SQLAlchemy</a>, <a href="http://www.sqlkorma.com/">Korma</a>,
<a href="http://www.jooq.org/">jOOQ</a> and probably hundreds of similar projects for
connecting to databases from code. Do we really need one more?</p>

<p>Well, Alf is a database connectivity library but it is first and foremost a
proposal for a new <em>kind</em> of database connectivity, or a paradigm shift if you
want. This new paradigm is called <strong>Relations as First-Class Citizen</strong> and it
makes Alf very different from the projects aforementionned. The difference
lies in the kind of abstraction that the library exposes to the software
developer: SQL queries for the former, <em>Relations</em> for the latter.</p>

<p>In almost all <a href="http://www.datomic.com/">but</a>
<a href="https://github.com/dkubb/axiom">a</a>
<a href="http://dbappbuilder.sourceforge.net/Rel.php">few</a> database connectivity
layers, the developer is indeed exposed to SQL queries. The SQL query is often
abstracted behind a higher-level API for manipulating its abstract syntax tree
(AST). But even in this case, the exposed abstraction is a SQL query. The fact
is that a SQL query, even when abstracted behind an AST, tends to be a very
poor abstraction for developing software. Before substantiating this claim,
let us illustrate the difference between our approach and those with a simple
example.</p>

<h3>Example</h3>

<p>In Java/JDBC for instance, queries are simple SQL strings. No abstraction at
all; we all know the cost in terms of maintenance, security, etc.</p>
<div class="highlight"><pre><span class="n">String</span> <span class="n">location</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">// from user input;</span>
<span class="n">String</span> <span class="n">qry</span>  <span class="o">=</span> <span class="s">&quot;SELECT name, city FROM suppliers WHERE&quot;</span><span class="o">;</span>
       <span class="n">qry</span> <span class="o">+=</span> <span class="s">&quot;city=&#39;&quot;</span> <span class="o">+</span> <span class="n">location</span> <span class="o">+</span> <span class="s">&quot;&#39;&quot;</span><span class="o">;</span>
</pre>
</div>

<p>Common high-level approaches are slightly more abstract. While more secure and
flexible, they still expose a SQL query abstraction. In the following example,
using <a href="https://github.com/rails/arel">ARel</a>:</p>
<div class="highlight"><pre><span class="n">location</span> <span class="o">=</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="c1"># from user input</span>
<span class="n">qry</span>  <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:suppliers</span><span class="p">)</span>
<span class="n">qry</span>  <span class="o">=</span> <span class="n">qry</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">qry</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span><span class="p">,</span> <span class="n">qry</span><span class="o">[</span><span class="ss">:city</span><span class="o">]</span><span class="p">)</span>
<span class="n">qry</span>  <span class="o">=</span> <span class="n">qry</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">qry</span><span class="o">[</span><span class="ss">:city</span><span class="o">].</span><span class="n">eq</span><span class="p">(</span><span class="n">location</span><span class="p">))</span>
</pre>
</div>

<p>The <strong>Relations as First-Class Citizen</strong> paradigm changes this by abstracting
from SQL and exposing true relations instead. In the example below,
<code>suppliers</code> is a relation, <code>restrict</code> is a relational operator and its
invocation returns another relation:</p>
<div class="highlight"><pre><span class="n">location</span> <span class="o">=</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="c1"># from user input</span>
<span class="n">restrict</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="ss">:city</span> <span class="o">=&gt;</span> <span class="n">location</span><span class="p">)</span>
</pre>
</div>

<div class="try-this" ><a ng-click="$state.transitionTo('try', {src: 'location = ... # from user input
restrict(suppliers, :city => location)'})">Try it!</a></div>

<h3>What does really change?</h3>

<p>This paradigm shift may not seem very significant at first glance, but
abstracting from SQL is an important change in practice:</p>

<ul>
<li><p>First, when exposing SQL as an software abstraction, you also expose its
type system. SQL&#39;s type system is poor and old. Developers need rich type
systems. In our new paradigm, the type system is the one of the host
language (Ruby in our case), with all its power:</p>
<div class="highlight"><pre><span class="c1"># Get suppliers whose name matches a Ruby regular expression.</span>
<span class="n">restrict</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">){</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">=~</span> <span class="sr">/J|B/</span> <span class="p">})</span>
</pre>
</div>

<div class="try-this" ><a ng-click="$state.transitionTo('try', {src: '# Get suppliers whose name matches a Ruby regular expression.
restrict(suppliers, ->(t){ t.name =~ /J|B/ })'})">Try it!</a></div>

<p>While powerful, this is very challenging in practice and comes at a cost: as
any abstraction, it leaks and you must be aware of the drawbacks and
limitations. We&#39;ll come back to this point at the end of this blog post.</p></li>
<li><p>SQL is a calculus. In contrast, the <strong>Relations as First-Class Citizen</strong>
paradigm relies on the availibility of an algebra. We claim that an algebra
exposes better abstractions for software engineering, as the rest of this
post will explain.</p></li>
</ul>

<h2>SQL, Relational Calculus vs. Relational Algebra</h2>

<p>SQL has been invented to allow <em>human beings</em> to query relational databases.
In fact, SQL is nearest to (tuple) relational calculus than to relational
algebra (for the sake of accuracy, it is a strange mix of both). To understand
our proposal, it is important to understand the difference in nature between a
calculus and an algebra:</p>

<ul>
<li><p>In a calculus, what you describe is the problem to solve, not how to solve
it. Hence the <code>from ... select ... such that ...</code> declarative kind of
question you actually ask to a SQL DBMS:</p>
<div class="highlight"><pre>  <span class="c1"># Get the cities where at least one supplier is located, provided</span>
  <span class="c1"># at least one part is located there too.</span>
  <span class="no">SELECT</span> <span class="no">DISTINCT</span> <span class="n">city</span> <span class="no">FROM</span> <span class="n">suppliers</span> <span class="no">AS</span> <span class="n">s</span>
  <span class="no">WHERE</span> <span class="no">EXISTS</span> <span class="p">(</span>
    <span class="no">SELECT</span> <span class="n">city</span> <span class="no">FROM</span> <span class="n">parts</span> <span class="no">AS</span> <span class="nb">p</span>
    <span class="no">WHERE</span> <span class="n">s</span><span class="o">.</span><span class="n">city</span> <span class="o">=</span> <span class="nb">p</span><span class="o">.</span><span class="n">city</span>
  <span class="p">)</span>
</pre>
</div></li>
<li><p>In contrast, with an algebra you manipulate symbols, that denote <em>values</em>,
through a predefined set of operators. You use those operators to <em>build</em>
or <em>reach</em> the solution to your problem:</p>
<div class="highlight"><pre>  <span class="c1"># Get the cities where at least one supplier is located, provided</span>
  <span class="c1"># at least one part is located there too.</span>
  <span class="n">cities_from_suppliers</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="o">[</span><span class="ss">:city</span><span class="o">]</span><span class="p">)</span>
  <span class="n">cities_from_parts</span>     <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="o">[</span><span class="ss">:city</span><span class="o">]</span><span class="p">)</span>
  <span class="n">intersect</span><span class="p">(</span><span class="n">cities_from_suppliers</span><span class="p">,</span> <span class="n">cities_from_parts</span><span class="p">)</span>
</pre>
</div>

<div class="try-this" ><a ng-click="$state.transitionTo('try', {src: '# Get the cities where at least one supplier is located, provided
# at least one part is located there too.
cities_from_suppliers = project(suppliers, [:city])
cities_from_parts     = project(parts, [:city])
intersect(cities_from_suppliers, cities_from_parts)'})">Try it!</a></div></li>
</ul>

<p>Relational calculus and relation algebra are known to be equivalent in
expressiveness. This is what allows Alf to compile the second form above to
something similar to the former one and to send it to an underlying SQL DBMS
(a feature obviously limited by the ability to reconcilie the respective type
systems, see later). However, as shown by the example above, a calculus is
more declarative than an algebra. In other words, the latter looks more like
an algorithm. Despite this, we do claim that relational algebra exposes better
abstractions for developing software when it comes to querying databases or,
more generally, to manipulating data. Why is that so?</p>

<h2>Querying databases vs. developing software</h2>

<p>When you (manually) query a database (either a SQL, a NoSQL one or whatever)
you generally know the problem at hand. Therefore, you welcome a declarative
language since it allows you to express that problem while leaving to the
underlying engine the job of finding the solution instead of having to
describe the algorithm to compute it. This is what SQL offers to you. This is
what <a href="https://bernardopires.com/2013/10/try-logic-programming-a-gentle-introduction-to-prolog/">logic
programming</a>
and <a href="http://en.wikipedia.org/wiki/Constraint_programming">constraint
programming</a> offer too.</p>

<p>Developping software is of a very different nature. As a software developer,
you generally don&#39;t have one single problem at hand. Instead, you have a set
of problems called <em>requirements</em> and you find a design that allows meeting
them all. One of the most effective strategy for this is <em>divide and conquer</em>.
A modular design, for example, helps achieving a good separation of concerns
with respect to those requirements while ensuring that the software behaves as
expected when all modules are put together.</p>

<p>The declarative styles of programming cited above are very nice for solving
very specific and well isolated sub-problems of your requirements space
(especially logic and constraint programming as they also allow searching
through an entire solution space). In contrast, they are of almost no aid for
putting the architectural pieces together. Yet, putting the pieces together is
something software engineers do every single day.</p>

<p>When it comes to manipulating data, putting <em>relations</em> together is much
easier than putting <em>SQL queries</em> together, because the semantics of &quot;putting
together&quot; is more straightfoward in the former case. This leads us back to the
calculus vs. algebra distinction. An algebra <em>is</em> about providing operators
for putting operands togethers, a calculus simply is not. The next section
illustrates this on our running example.</p>

<h2>The struggle of SQL with abstraction and reuse</h2>

<p>In the SQL query below observe the coupling induced by <code>s.city = p.city</code>
between the <code>FROM</code> clause and the <code>EXISTS</code> subquery:</p>
<div class="highlight"><pre><span class="no">SELECT</span> <span class="no">DISTINCT</span> <span class="n">city</span>
<span class="no">FROM</span> <span class="n">suppliers</span> <span class="no">AS</span> <span class="n">s</span>
<span class="no">WHERE</span> <span class="no">EXISTS</span> <span class="p">(</span>
  <span class="no">SELECT</span> <span class="n">city</span> <span class="no">FROM</span> <span class="n">parts</span> <span class="no">AS</span> <span class="nb">p</span>
  <span class="no">WHERE</span> <span class="n">s</span><span class="o">.</span><span class="n">city</span> <span class="o">=</span> <span class="nb">p</span><span class="o">.</span><span class="n">city</span>
<span class="p">)</span>
</pre>
</div>

<p>This kind of coupling explains why SQL-driven database connectivity librairies
stop shining as soon a join is involved, not even talking about more complex
queries. Indeed, even if possible, it is not idiomatic to build SQL queries
from various parts constructed in a really independent way. Common
connectivity libraries actually do a very hard job at trying to maintain the
illusion that it is possible, but they generally fail at doing so. To convince
yourself, suppose the following additional requirement:</p>
<div class="highlight"><pre><span class="c1"># Join the set of cities obtained previously with `cities` so as to also display their country.</span>
</pre>
</div>

<p>The most immediate way of writing such query seriously breaks separation of
concerns because you&#39;ll need to know a lot about how the previous building
block has been written. In particular, observe how the <code>SELECT</code> and <code>FROM</code>
clauses have to change:</p>
<div class="highlight"><pre><span class="no">SELECT</span> <span class="no">DISTINCT</span> <span class="n">s</span><span class="o">.</span><span class="n">city</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">country</span> 
<span class="no">FROM</span> <span class="n">suppliers</span> <span class="no">AS</span> <span class="n">s</span> <span class="no">JOIN</span> <span class="n">cities</span> <span class="no">AS</span> <span class="n">c</span> <span class="no">ON</span> <span class="n">s</span><span class="o">.</span><span class="n">city</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">city</span>
<span class="no">WHERE</span> <span class="no">EXISTS</span> <span class="p">(</span>
  <span class="no">SELECT</span> <span class="n">city</span> <span class="no">FROM</span> <span class="n">parts</span> <span class="no">AS</span> <span class="nb">p</span>
  <span class="no">WHERE</span> <span class="n">s</span><span class="o">.</span><span class="n">city</span> <span class="o">=</span> <span class="nb">p</span><span class="o">.</span><span class="n">city</span>
<span class="p">)</span>
</pre>
</div>

<p>There is actually a few ways to write such query without breaking abstraction
levels. For example, obverse how <code>q1</code> is preserved in the query below:</p>
<div class="highlight"><pre><span class="no">WITH</span> <span class="n">q1</span> <span class="no">AS</span> <span class="p">(</span>
       <span class="no">SELECT</span> <span class="no">DISTINCT</span> <span class="n">city</span>
       <span class="no">FROM</span> <span class="n">suppliers</span> <span class="no">AS</span> <span class="n">s</span>
       <span class="no">WHERE</span> <span class="no">EXISTS</span> <span class="p">(</span>
         <span class="no">SELECT</span> <span class="n">city</span> <span class="no">FROM</span> <span class="n">parts</span> <span class="no">AS</span> <span class="nb">p</span>
         <span class="no">WHERE</span> <span class="n">s</span><span class="o">.</span><span class="n">city</span> <span class="o">=</span> <span class="nb">p</span><span class="o">.</span><span class="n">city</span>
       <span class="p">)</span>
     <span class="p">),</span>
     <span class="n">q2</span> <span class="no">AS</span> <span class="p">(</span><span class="no">SELECT</span> <span class="n">city</span><span class="p">,</span> <span class="n">country</span> <span class="no">FROM</span> <span class="n">cities</span><span class="p">)</span>
<span class="no">SELECT</span> <span class="o">*</span> <span class="no">FROM</span> <span class="n">q1</span> <span class="no">NATURAL</span> <span class="no">JOIN</span> <span class="n">q2</span>
</pre>
</div>

<p>Ironically, building such a query with common connectivity libraries is not
idiomatic, when even possible. Worse, it is so hard to maintain this kind of
beasts that simply breaking your software design tends to be a better choice.
Last, but not least, if <code>cities</code> comes from another database, a .csv file or
whatever data source, the game simply ends.</p>

<h2>Relations provide a true abstraction mechanism</h2>

<p>The same is not true with relational algebra, more specifically with the
<strong>Relations as First-Class Citizen</strong> paradigm (RFCC). For instance, the
building block of our original solution above may be kept unchanged yet
further joined:</p>
<div class="highlight"><pre><span class="c1"># Get the cities where at least one supplier is located, provided</span>
<span class="c1"># at least one part is located there too.</span>
<span class="n">cities_from_suppliers</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="o">[</span><span class="ss">:city</span><span class="o">]</span><span class="p">)</span>
<span class="n">cities_from_parts</span>     <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="o">[</span><span class="ss">:city</span><span class="o">]</span><span class="p">)</span>
<span class="n">building_block</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">cities_from_suppliers</span><span class="p">,</span> <span class="n">cities_from_parts</span><span class="p">)</span>

<span class="c1"># Join the set of cities obtained previously with `cities` so as to also</span>
<span class="c1"># display their country.</span>
<span class="n">join</span><span class="p">(</span><span class="n">building_block</span><span class="p">,</span> <span class="n">cities</span><span class="p">)</span>
</pre>
</div>

<div class="try-this" ><a ng-click="$state.transitionTo('try', {src: '# Get the cities where at least one supplier is located, provided
# at least one part is located there too.
cities_from_suppliers = project(suppliers, [:city])
cities_from_parts     = project(parts, [:city])
building_block = intersect(cities_from_suppliers, cities_from_parts)

# Join the set of cities obtained previously with `cities` so as to also
# display their country.
join(building_block, cities)'})">Try it!</a></div>

<p>What if cities come from somewhere else? A .csv file, another database or
whatever datasource?</p>
<div class="highlight"><pre><span class="c1"># Get the cities... (unchanged, just inlined)</span>
<span class="n">building_block</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">project</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="o">[</span><span class="ss">:city</span><span class="o">]</span><span class="p">),</span> <span class="n">project</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="o">[</span><span class="ss">:city</span><span class="o">]</span><span class="p">))</span>

<span class="c1"># Join them...</span>
<span class="c1"># Might be Relation.load(&#39;cities.csv&#39;); we use a literal for execution on try-alf.org</span>
<span class="n">cities</span> <span class="o">=</span> <span class="no">Relation</span><span class="p">(</span><span class="o">[</span>
  <span class="p">{</span><span class="n">city</span><span class="p">:</span> <span class="s1">&#39;London&#39;</span><span class="p">,</span> <span class="n">country</span><span class="p">:</span> <span class="s1">&#39;England&#39;</span><span class="p">},</span>
  <span class="p">{</span><span class="n">city</span><span class="p">:</span> <span class="s1">&#39;Paris&#39;</span><span class="p">,</span>  <span class="n">country</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span><span class="p">}</span>
<span class="o">]</span><span class="p">)</span>
<span class="n">join</span><span class="p">(</span><span class="n">building_block</span><span class="p">,</span> <span class="n">cities</span><span class="p">)</span>
</pre>
</div>

<div class="try-this" ><a ng-click="$state.transitionTo('try', {src: '# Get the cities... (unchanged, just inlined)
building_block = intersect(project(suppliers, [:city]), project(parts, [:city]))

# Join them...
# Might be Relation.load(\'cities.csv\'); we use a literal for execution on try-alf.org
cities = Relation([
  {city: \'London\', country: \'England\'},
  {city: \'Paris\',  country: \'France\'}
])
join(building_block, cities)'})">Try it!</a></div>

<p>Relational algebra and RFCC can be seen as a purely functional kind of
programming where immutable values are relations and functions are relational
operators. This kind of comparison is not new. It was already suggested
several years ago in Ben Moseley&#39;s famous <a
href="http://shaffner.us/cs/papers/tarpit.pdf">Out of the Tar Pit</a> essay.
Alf contributes an example of the general framework outlined there.</p>

<h2>Limitations and future work</h2>

<p>The approach outlined here opens an avenue for further optimization,
experimentation and research. We close this blog post with an overview of our
own future work in this area. We also draw the reader attention on Alf&#39;s
current limitations.</p>

<h3>Towards high-level, domain-specific relational operators</h3>

<p>The closure property of relational algebra opens the ability to define new
relational operators in a very simple way, provided they are shortcuts over
longer expressions. Alf comes with such a facility, as illustrated below:</p>
<div class="highlight"><pre><span class="c1"># It relation `test` contains at least one tuple return `then_relation`,</span>
<span class="c1"># otherwise return `else_relation`</span>
<span class="k">def</span> <span class="nf">ite</span><span class="p">(</span><span class="nb">test</span><span class="p">,</span> <span class="n">then_relation</span><span class="p">,</span> <span class="n">else_relation</span><span class="p">)</span>
  <span class="n">union</span><span class="p">(</span>
    <span class="n">matching</span><span class="p">(</span><span class="n">then_relation</span><span class="p">,</span> <span class="n">project</span><span class="p">(</span><span class="nb">test</span><span class="p">,</span> <span class="o">[]</span><span class="p">)),</span>
    <span class="n">not_matching</span><span class="p">(</span><span class="n">else_relation</span><span class="p">,</span> <span class="n">project</span><span class="p">(</span><span class="nb">test</span><span class="p">,</span> <span class="o">[]</span><span class="p">)))</span>
<span class="k">end</span>

<span class="c1"># It there are at least one Red part, show suppliers in London, otherwise</span>
<span class="c1"># show suppliers in Paris</span>
<span class="n">ite</span><span class="p">(</span>
  <span class="n">restrict</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="s1">&#39;Red&#39;</span><span class="p">),</span>
  <span class="n">restrict</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="s1">&#39;London&#39;</span><span class="p">),</span>
  <span class="n">restrict</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="s1">&#39;Paris&#39;</span><span class="p">))</span>
</pre>
</div>

<div class="try-this" ><a ng-click="$state.transitionTo('try', {src: '# It relation `test` contains at least one tuple return `then_relation`,
# otherwise return `else_relation`
def ite(test, then_relation, else_relation)
  union(
    matching(then_relation, project(test, [])),
    not_matching(else_relation, project(test, [])))
end

# It there are at least one Red part, show suppliers in London, otherwise
# show suppliers in Paris
ite(
  restrict(parts, color: \'Red\'),
  restrict(suppliers, city: \'London\'),
  restrict(suppliers, city: \'Paris\'))'})">Try it!</a></div>

<p>While the example above is contrived, our experience suggests that the <code>ite</code>
relational operator proves very useful in practice when dealing with complex
data visibility and privacy requirements. Interresting enough, you can check
that the compilation involves only one SQL query sent to the underlying DBMS,
resulting in important performance improvements compared to other approaches
relying on an <code>if/then/else</code> statement in the host language.</p>

<p>Similarly, even when involving complex data types and collections, most query
plans involve a <em>constant</em> number of SQL queries, avoiding the &#39;N+1 queries&#39;
trap <a href="http://www.revision-zero.org/orm-haters-do-get-it">infamously known with Object-Relational
Mappers</a>:</p>
<div class="highlight"><pre><span class="n">join</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">group</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">supplies</span><span class="p">,</span> <span class="n">parts</span><span class="p">),</span> <span class="o">[</span><span class="ss">:sid</span><span class="o">]</span><span class="p">,</span> <span class="ss">:supplied_parts</span><span class="p">,</span> <span class="n">allbut</span><span class="p">:</span> <span class="kp">true</span><span class="p">))</span>
</pre>
</div>

<div class="try-this" ><a ng-click="$state.transitionTo('try', {src: 'join(suppliers, group(join(supplies, parts), [:sid], :supplied_parts, allbut: true))'})">Try it!</a></div>

<p>Alf already has a few high-level operators such as <a href="/doc/matching">matching</a>
or <a href="/doc/page">page</a>. The next release should include a few others currently
evaluated on case studies: <code>ite</code>, <code>image</code>, <code>abstract</code>, <code>quota</code>, etc.</p>

<h3>Database viewpoints</h3>

<p>The closure property of relational algebra also opens the ability to define
composable database viewpoints. Viewpoints provide a very effective
abstraction mechanism for implementing complex security/privacy requirements,
as well as providing context-aware database interfaces.</p>

<p>Without entering the details here, the following example illustrates the
approach by hacking on Ruby&#39;s <code>super</code> mechanism. Suppose we want to provide a
database viewpoint on suppliers and parts located in London:</p>
<div class="highlight"><pre><span class="c1"># Start of the viewpoint</span>
<span class="k">def</span> <span class="nf">suppliers</span>
  <span class="n">restrict</span><span class="p">(</span><span class="k">super</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="s1">&#39;London&#39;</span><span class="p">)</span>
<span class="k">end</span>
<span class="k">def</span> <span class="nf">parts</span>
  <span class="n">restrict</span><span class="p">(</span><span class="k">super</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="s1">&#39;London&#39;</span><span class="p">)</span>
<span class="k">end</span>
<span class="k">def</span> <span class="nf">supplies</span>
  <span class="c1"># restore foreign keys given the previous restrictions</span>
  <span class="n">matching</span><span class="p">(</span><span class="n">matching</span><span class="p">(</span><span class="k">super</span><span class="p">,</span> <span class="n">parts</span><span class="p">),</span> <span class="n">suppliers</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1"># End of the viewpoint</span>

<span class="c1"># Query as usual. This is entirely transparent.</span>
<span class="c1"># Check it yourself, supplier S2 no longer exists in this viewpoint.</span>
<span class="n">restrict</span><span class="p">(</span><span class="n">supplies</span><span class="p">,</span> <span class="n">sid</span><span class="p">:</span> <span class="s1">&#39;S1&#39;</span><span class="p">)</span>
</pre>
</div>

<div class="try-this" ><a ng-click="$state.transitionTo('try', {src: '# Start of the viewpoint
def suppliers
  restrict(super, city: \'London\')
end
def parts
  restrict(super, city: \'London\')
end
def supplies
  # restore foreign keys given the previous restrictions
  matching(matching(super, parts), suppliers)
end
# End of the viewpoint

# Query as usual. This is entirely transparent.
# Check it yourself, supplier S2 no longer exists in this viewpoint.
restrict(supplies, sid: \'S1\')'})">Try it!</a></div>

<h3>Reconciling heterogeneous type systems</h3>

<p>As already suggested, abstracting from SQL is challenging. More specifically,
abstracting from SQL <em>and</em> guaranteeing soundness and efficiency at the same
time are conflicting requirements. Alf has a smart compiler that delegates to
underlying engines what can be delegated, but the explicit use of the host
type system is a showstopper during compilation. To better understand this,
consider the following query:</p>
<div class="highlight"><pre><span class="n">restrict</span><span class="p">(</span>
  <span class="kp">extend</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">uppercased</span><span class="p">:</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">){</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upcase</span> <span class="p">}),</span>
  <span class="n">city</span><span class="p">:</span> <span class="s1">&#39;Paris&#39;</span><span class="p">,</span> <span class="n">uppercased</span><span class="p">:</span> <span class="s1">&#39;JONES&#39;</span><span class="p">)</span>
</pre>
</div>

<div class="try-this" ><a ng-click="$state.transitionTo('try', {src: 'restrict(
  extend(suppliers, uppercased: ->(t){ t.name.upcase }),
  city: \'Paris\', uppercased: \'JONES\')'})">Try it!</a></div>

<p>If you take a look at the query plan, you&#39;ll observe that the <code>restrict</code>
invocation is only partially compiled to SQL. The <code>uppercased</code> attribute is
computed by Alf in Ruby and cannot be translated back to the SQL engine. This
has serious performance implications, of course. As of current Alf version,
this is in true as soon as you use a ruby block (e.g. <code>->(t){ ... }</code>).</p>

<p>All other approaches we are aware of either have a similar problem or forbid
such queries in the first place (and are hence less expressive). This calls
for further symbiosis and interoperability between heterogeneous type systems
(SQL and Ruby in the present case).</p>

<h3>What about updates?</h3>

<p>We intentionnally left the question of database updates aside in this blog
post. Alf comes only with a very experimental interface for updates but a lot
of work is still needed in this area. Our general aim is to come with a well
chosen subset of relational operators supporting updates.</p>

<h2>Conclusion</h2>

<p>Arrived here? Kudos. Stay tuned, we&#39;ll provide more material soon. In the mean
time, enjoy Alf. Any question or contribution (of any kind) can be adressed by
sending an email to Bernard Lambeau (see the <a href="/about/">About</a> page).</p>
