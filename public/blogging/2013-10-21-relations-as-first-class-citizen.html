<div class="blog-post-date">2013, October 21</div>

<h1>Relations as First-Class Citizen - A Paradigm Shift for Software/Database Interoperability</h1>

<p>I&#39;m happy to announce that Alf <a href="https://rubygems.org/gems/alf">Alf 0.15.0</a> has
just been released and with it, this web site! I&#39;ve been thinking about all of
this for many years, often as a cross-cutting concern in <a href="http://scholar.google.be/citations?user=JsSMtA0AAAAJ&amp;hl=en">my (other) research
work</a>. I&#39;ve been
hacking on Alf in particular during my free time for more than two years now.
I think it was time to share it in a slightly more official way than as an
(almost invisible) <a href="https://github.com/alf-tool">open-source research
prototype</a> on github. Recent personal events gave
it a serious boost and a few people convinced me to give it more visibility.
So here we go.</p>

<p>Alf is a modern, powerful implementation of relational algebra. It brings
relational algebra where you don&#39;t necessarily expect it: in shell, in
scripting and for building complex software. Alf has an rich set of features.
Among them, it allows you to:</p>

<ul>
<li>Query .json, .csv, .yaml files and convert from one format to the other with
ease,</li>
<li>Query SQL databases with a sounder and more powerful query language than SQL
itself,</li>
<li>Export structured and so-called &quot;semi-structured&quot; query results in various
exchange formats,</li>
<li>Query multiple data sources as if they were one and only one database,</li>
<li>Create database <em>viewpoints</em> (mostly read-only viewpoints for now), to
provide your users with a true database interface while keeping them away
from data they may not have access to,</li>
<li>Enjoy a <a href="/doc/">rich set of relational operators</a> and even define your own
high-level and domain-specific ones.</li>
</ul>

<p>Alf is very young and not all of the advanced features are stable and/or
documented. I plan to spend some time in the next weeks and months to work on
them, so stay tuned. In the mean time, you can play with Alf on this website,
install <a href="https://rubygems.org/gems/alf">Alf 0.15.0</a> and start playing with it
on your own datasets and databases, <a href="/doc/pages/alf-in-shell">in shell</a> or
<a href="/doc/pages/alf-in-ruby">in ruby</a>. I&#39;ll come with advanced material on this
blog as soon as possible, I promise.</p>

<p>The rest of this post explains the context of this work and why it exists in
the first place, in the form of a (very accessible) scientific paper (this
writing style is also a test, let me know what you think). The <a href="#intro">following
section</a> provides a short overview of the proposed approach,
explaining the title of this blog post. We then detail Alf&#39;s proposal, first
with a <a href="#practice">short example</a> illustrating the advantages compared to
existing solutions, then with <a href="#theory">a more theoretical presentation</a>
covering three main questions:
<a href="#why-relational-algebra">why true relational algebra?</a>,
<a href="#what-type-system">what type system to expose?</a>, and
<a href="#why-not-classes-and-objects">why not classes and objects?</a>.
 <a href="#ongoing-work">Alf&#39;s limitations and features to come</a> are then
briefly discussed, before <a href="#conclusion">concluding</a>.</p>

<h2 id="intro">Yet another database connectivity library?</h2>

<p>We already have <a href="https://github.com/rails/arel">ARel</a>,
<a href="http://sequel.rubyforge.org/">Sequel</a>,
<a href="http://www.sqlalchemy.org/">SQLAlchemy</a>, <a href="http://www.sqlkorma.com/">Korma</a>,
<a href="http://www.jooq.org/">jOOQ</a> and probably hundreds of similar projects for
connecting to databases from code. Do we really need one more?</p>

<p>Well, Alf is a database connectivity library but it is first and foremost
about a proposal for a new <em>kind</em> of software/database interoperability, or a
paradigm shift if you want. This paradigm is called <strong>Relations as First-Class
Citizen</strong> and it makes Alf different from existing approaches. The difference
lies in the kind of data abstraction exposed to the software developer:</p>

<ul>
<li>Call-level interfaces (e.g. JDBC) expose SQL query strings and database
cursors (e.g. <code>java.sql.ResultSet</code>),</li>
<li>Higher-level SQL libraries, such as <a href="https://github.com/rails/arel">ARel</a>,
<a href="http://sequel.rubyforge.org/">Sequel</a>, and <a href="http://www.jooq.org/">jOOQ</a>
expose SQL queries as well. However, they abstract them behind abstract
syntax trees (AST), and algebra-inspired manipulation operators.</li>
<li>Object-Relational Mappers (ORMs) expose classes and objects together with
the SQL/AST interface they generally rely on (e.g. the symbiosis between
<a href="https://github.com/rails/arel">ARel</a> and
<a href="http://guides.rubyonrails.org/active_record_querying.html">ActiveRecord</a>),</li>
<li><a href="https://github.com/alf-tool/alf">Alf</a> and
<a href="https://github.com/dkubb/axiom">Axiom</a> expose <em>Relations</em> (i.e. <a href="/doc/pages/relational-basics">sets of
tuples</a>) and relational algebra. For those
interested, I&#39;ll discuss some differences between Alf and Axiom later in this
blog post. In the mean time and unless stated otherwise, what is said about
Alf applies to Axiom too.</li>
</ul>

<p>In this blog post, I&#39;m going to compare Alf with the second category above,
i.e. high-level SQL-driven libraries. Not because the <strong>Relations as
First-Class Citizen</strong> paradigm cannot be compared to, say, Object-Relational
Mapping but because, at first glance, Alf shares a lot more with those
libraries than with ORMs. First things first thus, let start looking at those
similitudes and (sometimes subtle) differences. We start with a motivating
example in the next section before moving to more theoretical arguments in the one immediately following.</p>

<h2 id="practice">Motivating example</h2>

<p><i>This might appear rude or offensive, but I need to start by complaining
about existing approaches and libraries (why would I work on Alf in the first
place otherwise?). <a href="http://sequel.rubyforge.org/">Sequel</a> is used in this blog
post but the situation is similar with all the libraries I mentioned
previously. I&#39;ve chosen Sequel because I commonly use and actually</i> love
<i>it. No offense to be taken therefore even if I claim, in essence, that
things could be improved.</i></p>

<p>My main complaint is that, despite providing <a href="http://en.wikipedia.org/wiki/Closure_(mathematics)">closure under
operations</a>, existing
libraries fail at providing a truly composable way of tackling data
requirements. To understand why, let me take a concrete software engineering
example on (a slighly modified version of) the <a href="http://en.wikipedia.org/wiki/Suppliers_and_Parts_database">suppliers and parts
examplar</a>. We&#39;ll
use the following <a href="/?src=c3VwcGxpZXJz"><code>suppliers</code></a> and
<a href="/?src=Y2l0aWVz"><code>cities</code></a> relations:</p>
<div class="highlight"><pre><span class="n">suppliers</span><span class="p">:</span>                                     <span class="n">cities</span><span class="p">:</span>
<span class="o">+------+-------+---------+--------+</span>            <span class="o">+----------+----------+</span>
<span class="o">|</span> <span class="ss">:sid</span> <span class="o">|</span> <span class="ss">:name</span> <span class="o">|</span> <span class="ss">:status</span> <span class="o">|</span> <span class="ss">:city</span>  <span class="o">|</span>            <span class="o">|</span> <span class="ss">:city</span>    <span class="o">|</span> <span class="ss">:country</span> <span class="o">|</span>
<span class="o">+------+-------+---------+--------+</span>            <span class="o">+----------+----------+</span>
<span class="o">|</span> <span class="no">S1</span>   <span class="o">|</span> <span class="no">Smith</span> <span class="o">|</span>      <span class="mi">20</span> <span class="o">|</span> <span class="no">London</span> <span class="o">|</span>            <span class="o">|</span> <span class="no">London</span>   <span class="o">|</span> <span class="no">England</span>  <span class="o">|</span>
<span class="o">|</span> <span class="no">S2</span>   <span class="o">|</span> <span class="no">Jones</span> <span class="o">|</span>      <span class="mi">10</span> <span class="o">|</span> <span class="no">Paris</span>  <span class="o">|</span>            <span class="o">|</span> <span class="no">Paris</span>    <span class="o">|</span> <span class="no">France</span>   <span class="o">|</span>
<span class="o">|</span> <span class="no">S3</span>   <span class="o">|</span> <span class="no">Blake</span> <span class="o">|</span>      <span class="mi">30</span> <span class="o">|</span> <span class="no">Paris</span>  <span class="o">|</span>            <span class="o">|</span> <span class="no">Athens</span>   <span class="o">|</span> <span class="no">Greece</span>   <span class="o">|</span>
<span class="o">|</span> <span class="no">S4</span>   <span class="o">|</span> <span class="no">Clark</span> <span class="o">|</span>      <span class="mi">20</span> <span class="o">|</span> <span class="no">London</span> <span class="o">|</span>            <span class="o">|</span> <span class="no">Brussels</span> <span class="o">|</span> <span class="no">Belgium</span>  <span class="o">|</span>
<span class="o">|</span> <span class="no">S5</span>   <span class="o">|</span> <span class="no">Adams</span> <span class="o">|</span>      <span class="mi">30</span> <span class="o">|</span> <span class="no">Athens</span> <span class="o">|</span>            <span class="o">+----------+----------+</span>
<span class="o">+------+-------+---------+--------+</span>
</pre>
</div>

<p>Let suppose that the suppliers themselves are the software users and that the
following requirements must be met by the particular inferface showing the
list of suppliers to the current user:</p>

<ol>
<li>A supplier may only see information about the suppliers located in the same
city than himself.</li>
<li>The supplier&#39;s <code>status</code> is sensitive and should not be displayed.</li>
<li>The country name must be displayed together with the supplier&#39;s city</li>
</ol>

<p>In terms of the query to be built, those requirements involve a restriction
(<code>same city as</code>), a selection (<code>no status</code>) and a join (<code>with country name</code>).
Suppose you are supplier <code>S3</code>, the list of suppliers you see <a href="/?src=cmVxdWVzdGVyID0gIlMzIgpqb2luKGFsbGJ1dChtYXRjaGluZyhzdXBwbGllcnMsIHByb2plY3QocmVzdHJpY3Qoc3VwcGxpZXJzLCBzaWQ6IHJlcXVlc3RlciksIFs6Y2l0eV0pKSwgWzpzdGF0dXNdKSwgY2l0aWVzKQ">looks like
this</a>:</p>
<div class="highlight"><pre><span class="o">+------+-------+-------+----------+</span>
<span class="o">|</span> <span class="ss">:sid</span> <span class="o">|</span> <span class="ss">:name</span> <span class="o">|</span> <span class="ss">:city</span> <span class="o">|</span> <span class="ss">:country</span> <span class="o">|</span>
<span class="o">+------+-------+-------+----------+</span>
<span class="o">|</span> <span class="no">S2</span>   <span class="o">|</span> <span class="no">Jones</span> <span class="o">|</span> <span class="no">Paris</span> <span class="o">|</span> <span class="no">France</span>   <span class="o">|</span>
<span class="o">|</span> <span class="no">S3</span>   <span class="o">|</span> <span class="no">Blake</span> <span class="o">|</span> <span class="no">Paris</span> <span class="o">|</span> <span class="no">France</span>   <span class="o">|</span>
<span class="o">+------+-------+-------+----------+</span>
</pre>
</div>

<h3 id="struggling">Struggling with reuse and separation of concerns</h3>

<p>Writting a monolithic query is rather straightforward. Using <a href="http://sequel.rubyforge.org/">Sequel</a> for instance:</p>
<div class="highlight"><pre><span class="n">requester_city</span> <span class="o">=</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="c1"># from context (authenticated user)</span>

<span class="no">DB</span><span class="o">[</span><span class="ss">:suppliers</span><span class="o">]</span>
  <span class="o">.</span><span class="n">natural_join</span><span class="p">(</span><span class="ss">:cities</span><span class="p">)</span>
  <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="ss">:sid</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:city</span><span class="p">,</span> <span class="ss">:country</span><span class="p">)</span>
  <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="ss">:city</span> <span class="o">=&gt;</span> <span class="n">requester_city</span><span class="p">)</span>

<span class="c1"># =&gt; SELECT sid, name, city, country</span>
<span class="c1">#    FROM suppliers NATURAL JOIN cities</span>
<span class="c1">#    WHERE (city = ...)</span>
</pre>
</div>

<p>In software involving complex requirements, relying on monolithic queries is
unfortunately not always possible and/or desirable (otherwise, creating
database views would simply be enough). Two main reasons explain this:</p>

<ul>
<li>The same requirements tend to apply to various and independent software
features. For instance, the first two requirements above might apply
<em>everytime</em> a list of suppliers is shown, while the third one might not.
Complex requirements generally call for a design that achieves both
separation of concerns and reuse.</li>
<li>Complex software also involves context-dependent requirements. For instance,
the first requirement above might be relaxed for administrators (say,
suppliers with status greater than 30).</li>
</ul>

<p>This explains why connectivity libraries and their SQL utilities exist in the
first place: because of the need to <em>build</em> queries, often at runtime and
according to some context. There is a desperate need for more support for this
in DBMSs themselves. In the mean time, developers rely on the ability of host
programming languages and third-party libraries.</p>

<p>Back to our example above, what about the following &quot;design&quot;?</p>
<div class="highlight"><pre><span class="c1"># Meet 1) and 2) together as a utility method: separation of concerns</span>
<span class="k">def</span> <span class="nf">suppliers_in</span><span class="p">(</span><span class="n">city</span><span class="p">)</span>
  <span class="no">DB</span><span class="o">[</span><span class="ss">:suppliers</span><span class="o">]</span>
    <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="ss">:sid</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:city</span><span class="p">)</span>
    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="ss">:city</span> <span class="o">=&gt;</span> <span class="n">city</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># Meet 3) as a utility method: separation of concerns</span>
<span class="k">def</span> <span class="nf">with_country</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
  <span class="n">operand</span><span class="o">.</span><span class="n">natural_join</span><span class="p">(</span><span class="ss">:cities</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># Meet them all: composition and reuse</span>
<span class="n">requester_city</span> <span class="o">=</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="c1"># from context</span>
<span class="n">with_country</span><span class="p">(</span><span class="n">suppliers_in</span><span class="p">(</span><span class="n">requester_city</span><span class="p">))</span>
</pre>
</div>

<p>Wrong. The original, and correct, SQL query was:</p>
<div class="highlight"><pre><span class="c1">-- Give the id, name, city and country of every supplier located in city ...</span>
<span class="k">SELECT</span> <span class="n">sid</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">city</span><span class="p">,</span> <span class="n">country</span>
<span class="k">FROM</span> <span class="n">suppliers</span> <span class="k">NATURAL</span> <span class="k">JOIN</span> <span class="n">cities</span>
<span class="k">WHERE</span> <span class="p">(</span><span class="n">city</span> <span class="o">=</span> <span class="p">...)</span>
</pre>
</div>

<p>The new one seems smiliar, but is wrong. As shown below, we lost the country
in the process:</p>
<div class="highlight"><pre><span class="c1">-- Give the id, name and city of every supplier located in city ..., provided</span>
<span class="c1">-- the city is known in `cities`</span>
<span class="k">SELECT</span> <span class="n">sid</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">city</span>
<span class="k">FROM</span> <span class="n">suppliers</span> <span class="k">NATURAL</span> <span class="k">JOIN</span> <span class="n">cities</span>
<span class="k">WHERE</span> <span class="p">(</span><span class="n">city</span> <span class="o">=</span> <span class="p">...)</span>
</pre>
</div>

<p>What happened? In short, <code>Sequel</code>&#39;s join does not correspond to a <em>algebraic</em>
join of its operands. Instead, its specification looks like &quot;adds a term to
the <code>SQL</code> query&#39;s <code>FROM</code> clause&quot;, whose data semantics is far from obvious
(here you can blame <code>SQL</code> itself). Observe in particular that the following
algebraic equivalence does not hold in <code>Sequel</code>, preventing us from using the
design above:</p>
<div class="highlight"><pre><span class="n">suppliers</span>
  <span class="o">.</span><span class="n">natural_join</span><span class="p">(</span><span class="n">cities</span><span class="p">)</span>
  <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="ss">:sid</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:city</span><span class="p">,</span> <span class="ss">:country</span><span class="p">)</span>
<span class="o">&lt;=!=&gt;</span>
<span class="n">suppliers</span>
  <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="ss">:sid</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:city</span><span class="p">)</span>
  <span class="o">.</span><span class="n">natural_join</span><span class="p">(</span><span class="n">cities</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="ss">:city</span><span class="p">,</span> <span class="ss">:country</span><span class="p">))</span>
</pre>
</div>

<p>Join is a striking example of the problem at hand, but others exist that
involve different operators. Let me insist on something: the same is true with
<a href="https://github.com/rails/arel">ARel</a>, <a href="http://sequel.rubyforge.org/">Sequel</a>,
<a href="http://www.sqlalchemy.org/">SQLAlchemy</a>, <a href="http://www.sqlkorma.com/">Korma</a>,
<a href="http://www.jooq.org/">jOOQ</a> to cite a few. The fact is:</p>

<ul>
<li>SQL has not been designed with composition and separation of concerns in
mind,</li>
<li>Avoiding strong coupling between subqueries tends to be very difficult in
practice,</li>
<li>Coupling hurts separation of concerns and software design.</li>
</ul>

<p>To be fair... There <em>is</em> a way to use <code>SQL</code> (and, sometimes, those libraries)
so as to avoid the problem described here. It amounts at using <code>SQL</code> in a
purely algebraic way. Unfortunately, that way is not idiomatic and leads to
complex SQL queries, that may have bad execution plans (at least in major
open-source DBMSs). In the example at hand, using Sequel&#39;s <code>from_self</code> in a
systematic way (e.g. on every reusable piece) is safe from the point of view
of composition and reuse:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">suppliers_in</span><span class="p">(</span><span class="n">city</span><span class="p">)</span>
  <span class="no">DB</span><span class="o">[</span><span class="ss">:suppliers</span><span class="o">]</span>
    <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="ss">:sid</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:city</span><span class="p">)</span>
    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="ss">:city</span> <span class="o">=&gt;</span> <span class="n">city</span><span class="p">)</span>
    <span class="o">.</span><span class="n">from_self</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">with_country</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>
  <span class="n">operand</span>
    <span class="o">.</span><span class="n">natural_join</span><span class="p">(</span><span class="ss">:cities</span><span class="p">)</span>
    <span class="o">.</span><span class="n">from_self</span>
<span class="k">end</span>

<span class="n">requester_city</span> <span class="o">=</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="c1"># from context</span>
<span class="n">with_country</span><span class="p">(</span><span class="n">suppliers_in</span><span class="p">(</span><span class="n">requester_city</span><span class="p">))</span>

<span class="c1"># SELECT * FROM (</span>
<span class="c1">#   SELECT * FROM (</span>
<span class="c1">#     SELECT sid, name, city FROM suppliers</span>
<span class="c1">#     WHERE (city = ...)</span>
<span class="c1">#   ) AS &#39;t1&#39;</span>
<span class="c1">#   NATURAL JOIN cities</span>
<span class="c1"># ) AS &#39;t1&#39;</span>
</pre>
</div>

<p>The complete recipe for using SQL in such a &quot;safe&quot; way is more complex, of
course, but possible. I won&#39;t provide the details in this blog post, let me
know if a dedicated one is welcome. For now, let see how our new paradigm
helps.</p>

<h3>Relation Algebra at the rescue...</h3>

<p>Libraries like Sequel and Arel offer closure under operations, meaning that
you can chain operator invocations (e.g.
<code>operand.select(...).where(...).where(...)</code>). Subtly enough, that does not
make them exposing an algebra, because SQL is not itself a pure relational
algebra (see <a href="#why-relational-algebra">later</a>) and these libraries do espouse
SQL in a rather faithful way.</p>

<p>In contrast, the <strong>Relations as First-Class Citizen</strong> paradigm aims at
providing an interface that is <em>designed for</em> composition and reuse. To
achieve this, Alf takes some distance from SQL and exposes a true relational
algebra instead, inspired from <a
href="http://en.wikipedia.org/wiki/D_(data_language_specification)"
target="_blank"><b>Tutorial D</b></a>. This makes a real difference, even if
subtle. To convince yourself, I invite you to use
<a href="/?src=cmVxdWVzdGVyX2NpdHkgPSAnUGFyaXMnCnNvbHV0aW9uID0gc3VwcGxpZXJzCgojIDEpLiBBIHN1cHBsaWVyIG1heSBvbmx5IHNlZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3VwcGxpZXJzIGxvY2F0ZWQKIyBpbiB0aGUgc2FtZSBjaXR5IHRoYW4gaGltc2VsZi4Kc29sdXRpb24gPSByZXN0cmljdChzb2x1dGlvbiwgY2l0eTogcmVxdWVzdGVyX2NpdHkpCgojIDIpIFRoZSBzdXBwbGllcidzIGBzdGF0dXNgIGlzIHNlbnNpdGl2ZSBhbmQgc2hvdWxkIG5vdCBiZSBkaXNwbGF5ZWQuCnNvbHV0aW9uID0gYWxsYnV0KHNvbHV0aW9uLCBbOnN0YXR1c10pCgojIDMpLiBUaGUgY291bnRyeSBuYW1lIG11c3QgYmUgZGlzcGxheWVkIHRvZ2V0aGVyIHdpdGggdGhlIHN1cHBsaWVyJ3MgY2l0eS4Kc29sdXRpb24gPSBqb2luKHNvbHV0aW9uLCBjaXRpZXMp">Alf&#39;s Try console</a>
to check that the example below works as expected. As shown, the three
requirements of our case study can be incorporated incrementally thanks to the
true composition mechanism offered by an algebra. Commenting a line amounts at
ignoring the corresponding requirement:</p>
<div class="highlight"><pre><span class="n">requester_city</span> <span class="o">=</span> <span class="s1">&#39;Paris&#39;</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">suppliers</span>

<span class="c1"># 1). A supplier may only see information about the suppliers located</span>
<span class="c1"># in the same city than himself.</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">restrict</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="n">requester_city</span><span class="p">)</span>

<span class="c1"># 2) The supplier&#39;s `status` is sensitive and should not be displayed.</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">allbut</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="o">[</span><span class="ss">:status</span><span class="o">]</span><span class="p">)</span>

<span class="c1"># 3). The country name must be displayed together with the supplier&#39;s city.</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">cities</span><span class="p">)</span>
</pre>
</div>

<div class="try-this"><a href="/?src=cmVxdWVzdGVyX2NpdHkgPSAnUGFyaXMnCnNvbHV0aW9uID0gc3VwcGxpZXJz
CgojIDEpLiBBIHN1cHBsaWVyIG1heSBvbmx5IHNlZSBpbmZvcm1hdGlvbiBh
Ym91dCB0aGUgc3VwcGxpZXJzIGxvY2F0ZWQKIyBpbiB0aGUgc2FtZSBjaXR5
IHRoYW4gaGltc2VsZi4Kc29sdXRpb24gPSByZXN0cmljdChzb2x1dGlvbiwg
Y2l0eTogcmVxdWVzdGVyX2NpdHkpCgojIDIpIFRoZSBzdXBwbGllcidzIGBz
dGF0dXNgIGlzIHNlbnNpdGl2ZSBhbmQgc2hvdWxkIG5vdCBiZSBkaXNwbGF5
ZWQuCnNvbHV0aW9uID0gYWxsYnV0KHNvbHV0aW9uLCBbOnN0YXR1c10pCgoj
IDMpLiBUaGUgY291bnRyeSBuYW1lIG11c3QgYmUgZGlzcGxheWVkIHRvZ2V0
aGVyIHdpdGggdGhlIHN1cHBsaWVyJ3MgY2l0eS4Kc29sdXRpb24gPSBqb2lu
KHNvbHV0aW9uLCBjaXRpZXMp
" target="_blank">Try it!</a></div>

<p>To better understand why it works, observe that in Alf, the equivalence
mentionned in the previous section holds. That is, the two following queries
are equivalent, something that you can check by yourself using the console:</p>
<div class="highlight"><pre><span class="n">project</span><span class="p">(</span>
  <span class="n">join</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">cities</span><span class="p">),</span>
  <span class="o">[</span><span class="ss">:sid</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:city</span><span class="p">,</span> <span class="ss">:country</span><span class="o">]</span><span class="p">)</span>
</pre>
</div>

<div class="try-this"><a href="/?src=cHJvamVjdCgKICBqb2luKHN1cHBsaWVycywgY2l0aWVzKSwKICBbOnNpZCwg
Om5hbWUsIDpjaXR5LCA6Y291bnRyeV0p
" target="_blank">Try it!</a></div>

<p>and</p>
<div class="highlight"><pre><span class="n">join</span><span class="p">(</span>
  <span class="n">project</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="o">[</span><span class="ss">:sid</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:city</span><span class="o">]</span><span class="p">),</span>
  <span class="n">project</span><span class="p">(</span><span class="n">cities</span><span class="p">,</span> <span class="o">[</span><span class="ss">:city</span><span class="p">,</span> <span class="ss">:country</span><span class="o">]</span><span class="p">))</span>
</pre>
</div>

<div class="try-this"><a href="/?src=am9pbigKICBwcm9qZWN0KHN1cHBsaWVycywgWzpzaWQsIDpuYW1lLCA6Y2l0
eV0pLAogIHByb2plY3QoY2l0aWVzLCBbOmNpdHksIDpjb3VudHJ5XSkp
" target="_blank">Try it!</a></div>

<p>Interestingly enough, this kind of equivalences may be used for query
optimization and smart SQL compilation. I invite you to check the <code>Optimizer</code>
and <code>Query plan</code> tabs of the console on both queries. The generated SQL query
is the same in both cases. Alf tries very hard to keep generated SQL as simple
as possible, in the hope to avoid ugly query plans in the SQL DBMS itself:</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="n">t1</span><span class="p">.</span><span class="n">sid</span> <span class="k">AS</span> <span class="n">sid</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">name</span> <span class="k">AS</span> <span class="n">name</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="n">city</span> <span class="k">AS</span> <span class="n">city</span><span class="p">,</span> <span class="n">t2</span><span class="p">.</span><span class="n">country</span> <span class="k">AS</span> <span class="n">country</span>
<span class="k">FROM</span> <span class="n">suppliers</span> <span class="k">AS</span> <span class="n">t1</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">cities</span> <span class="k">AS</span> <span class="n">t2</span> <span class="k">ON</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">city</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">city</span><span class="p">)</span>
</pre>
</div>

<h3>... plus extra</h3>

<p>What if the <code>cities</code> tuples (that does not actually exists in the original
suppliers and parts examplar), come from somewhere else? A .csv file, another
database or whatever datasource?</p>
<div class="highlight"><pre><span class="n">requester_city</span> <span class="o">=</span> <span class="s1">&#39;Paris&#39;</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">suppliers</span>

<span class="c1"># 1) and 2) above, but inline</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">allbut</span><span class="p">(</span><span class="n">restrict</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="n">requester_city</span><span class="p">),</span> <span class="o">[</span><span class="ss">:status</span><span class="o">]</span><span class="p">)</span>

<span class="c1"># Might be Relation.load(&#39;cities.csv&#39;); we use a literal for execution on try-alf.org</span>
<span class="n">third_party_cities</span> <span class="o">=</span> <span class="no">Relation</span><span class="p">(</span><span class="o">[</span>
  <span class="p">{</span><span class="n">city</span><span class="p">:</span> <span class="s1">&#39;London&#39;</span><span class="p">,</span> <span class="n">country</span><span class="p">:</span> <span class="s1">&#39;England&#39;</span><span class="p">},</span>
  <span class="p">{</span><span class="n">city</span><span class="p">:</span> <span class="s1">&#39;Paris&#39;</span><span class="p">,</span>  <span class="n">country</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span><span class="p">}</span>
<span class="o">]</span><span class="p">)</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">third_party_cities</span><span class="p">)</span>
</pre>
</div>

<div class="try-this"><a href="/?src=cmVxdWVzdGVyX2NpdHkgPSAnUGFyaXMnCnNvbHV0aW9uID0gc3VwcGxpZXJz
CgojIDEpIGFuZCAyKSBhYm92ZSwgYnV0IGlubGluZQpzb2x1dGlvbiA9IGFs
bGJ1dChyZXN0cmljdChzb2x1dGlvbiwgY2l0eTogcmVxdWVzdGVyX2NpdHkp
LCBbOnN0YXR1c10pCgojIE1pZ2h0IGJlIFJlbGF0aW9uLmxvYWQoJ2NpdGll
cy5jc3YnKTsgd2UgdXNlIGEgbGl0ZXJhbCBmb3IgZXhlY3V0aW9uIG9uIHRy
eS1hbGYub3JnCnRoaXJkX3BhcnR5X2NpdGllcyA9IFJlbGF0aW9uKFsKICB7
Y2l0eTogJ0xvbmRvbicsIGNvdW50cnk6ICdFbmdsYW5kJ30sCiAge2NpdHk6
ICdQYXJpcycsICBjb3VudHJ5OiAnRnJhbmNlJ30KXSkKc29sdXRpb24gPSBq
b2luKHNvbHV0aW9uLCB0aGlyZF9wYXJ0eV9jaXRpZXMp
" target="_blank">Try it!</a></div>

<p>The example above shows that, in addition to the advantages previously cited,
the composition mechanism of relational algebra, unlike SQL queries, makes few
assumptions about where the operands come from, by very nature. In a sense,
the <strong>Relations as First-class citizen</strong> can be seen as a purely functional
kind of programming where immutable values are relations and functions are
relational operators. This kind of comparison is not new. It was already
suggested several years ago in Ben Moseley&#39;s famous <a
href="http://shaffner.us/cs/papers/tarpit.pdf">Out of the Tar Pit</a> essay.
Alf contributes an example of the general framework outlined there.</p>

<h2 id="theory">More about the paradigm and its motivation</h2>

<p>Moving from SQL to a relational algebra is one of the changes underlying the
<strong>Relations as First-Class Citizen</strong> paradigm for software/database
interoperability, but it is not the only one and maybe not the most important
(?). The following subsections detail the paradigm further and provides
motivations and theoretical arguments. They address the three following
questions:</p>

<ul>
<li><a href="#why-relational-algebra">Why relational algebra</a> is a better choice than
relational calculus for developing software?</li>
<li><a href="#what-type-system">What type system</a> do we want to expose to software developers? SQL&#39;s one or the host language&#39;s?</li>
<li><a href="#why-not-classes-and-objects">Why <em>relations</em></a> instead of traditional <em>classes and objects</em> for structural concepts?</li>
</ul>

<h3 id="why-relational-algebra">From Relational Calculus (SQL) to Relational Algebra</h3>

<p>In my opinion, the fact that SQL is used daily by software developers is the
result of an historical mistake, or a misfortune at least. Indeed, SQL has
been invented in the database community at a time where it was envisioned that
<em>end users</em> would query relational databases. This is more than 40 years ago.
At that time, the nature of software, software engineering, requirements
engineering and human-software interactions were not understood as they are
today.</p>

<p>With this envisioned reality in mind, SQL has been chosen nearer to (tuple)
relational calculus than to relational algebra (for the sake of accuracy, it
is a strange mix of both; yet another obscure historical reasons explain
this). For a good understanding of the discussion here, it is important to
understand the difference in nature between a calculus and an algebra:</p>

<ul>
<li><p>In a calculus, what you describe is the problem to solve, not how to solve
it. Hence the <code>from ... select ... such that ...</code> declarative kind of
question you ask to an SQL DBMS:</p>
<div class="highlight"><pre>  <span class="c1">-- Get the cities where at least one supplier is located, provided</span>
  <span class="c1">-- at least one part is located there too.</span>
  <span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">suppliers</span> <span class="k">AS</span> <span class="n">s</span>
  <span class="k">WHERE</span> <span class="k">EXISTS</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">city</span> <span class="k">FROM</span> <span class="n">parts</span> <span class="k">AS</span> <span class="n">p</span>
    <span class="k">WHERE</span> <span class="n">s</span><span class="p">.</span><span class="n">city</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">city</span>
  <span class="p">)</span>
</pre>
</div></li>
<li><p>In contrast, with an algebra you manipulate symbols, that denote <em>values</em>,
through a predefined set of operators. You use those operators to <em>build</em>
or <em>reach</em> the solution to your problem:</p>
<div class="highlight"><pre>  <span class="c1"># Get the cities where at least one supplier is located, provided</span>
  <span class="c1"># at least one part is located there too.</span>
  <span class="n">cities_from_suppliers</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="o">[</span><span class="ss">:city</span><span class="o">]</span><span class="p">)</span>
  <span class="n">cities_from_parts</span>     <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="o">[</span><span class="ss">:city</span><span class="o">]</span><span class="p">)</span>
  <span class="n">intersect</span><span class="p">(</span><span class="n">cities_from_suppliers</span><span class="p">,</span> <span class="n">cities_from_parts</span><span class="p">)</span>
</pre>
</div>

<div class="try-this"><a href="/?src=IyBHZXQgdGhlIGNpdGllcyB3aGVyZSBhdCBsZWFzdCBvbmUgc3VwcGxpZXIg
aXMgbG9jYXRlZCwgcHJvdmlkZWQKIyBhdCBsZWFzdCBvbmUgcGFydCBpcyBs
b2NhdGVkIHRoZXJlIHRvby4KY2l0aWVzX2Zyb21fc3VwcGxpZXJzID0gcHJv
amVjdChzdXBwbGllcnMsIFs6Y2l0eV0pCmNpdGllc19mcm9tX3BhcnRzICAg
ICA9IHByb2plY3QocGFydHMsIFs6Y2l0eV0pCmludGVyc2VjdChjaXRpZXNf
ZnJvbV9zdXBwbGllcnMsIGNpdGllc19mcm9tX3BhcnRzKQ==
" target="_blank">Try it!</a></div></li>
</ul>

<p>As shown by the example above, a calculus is more declarative than an algebra.
In other words, the latter looks more like an algorithm. This explains why
SQL, probably the most idiomatic <em>end-user</em> query language ever, has been
designed as a calculus. As an end-user, when you (manually) query a database
you generally know the problem at hand. Therefore, you welcome a declarative
language since it allows you to express that problem while leaving to the
underlying engine the job of finding the solution instead of having to
describe the algorithm to compute it. <em>This</em> is what SQL offers to its users.</p>

<p>Now, I suppose it is not too risky to claim that, today, a large majority of
interactions with databases is done by software components, possibly on behalf
of their end users, and generally in accordance to specific requirements. The
<em>actual</em> users of (relational) databases are not end-users after all, but
software components and, indirectly, their developers.</p>

<p>Yet, developping software is of a very different nature than querying
databases. As a software engineer, you generally don&#39;t have one single problem
at hand. Instead, you have a set of problems called <em>requirements</em> and you
find a design that allows meeting them all (cfr. <a href="#practice">the previous
section</a> for an example). One of the most effective strategies
available in the software engineer toolset is <em>divide and conquer</em>. A modular
design, for example, helps achieving a good separation of concerns with
respect to those requirements while ensuring that the software behaves as
expected when all modules are put together.</p>

<p>While the declarative style of programming of SQL is very nice for solving
very specific and well isolated sub-problems in your requirements &amp; design
space, it is of almost no aid for putting the architectural pieces together.
Yet, putting the pieces together is something software engineers do every
single day. And so is writing algorithms. Exposing a relational algebra
therefore appears more natural when it comes to software development, and when
it comes to <em>manipulating</em> data vs. <em>querying</em> database. To be fair, libraries
such as <a href="https://github.com/rails/arel">ARel</a>,
<a href="http://sequel.rubyforge.org/">Sequel</a>, and <a href="http://www.jooq.org/">jOOQ</a>
already show the way: they provide an API that is closer to relational
algebra than relational calculus. <a href="https://github.com/alf-tool/alf">Alf</a> and
<a href="https://github.com/dkubb/axiom">Axiom</a> simply go further this path by
abstracting from SQL and choosing a sound algebra known as <a
href="http://en.wikipedia.org/wiki/D_(data_language_specification)"
target="_blank"><b>Tutorial D</b></a> as a better inspiration than SQL towards
the same objective.</p>

<p>The <strong>Relations as First-Class Citizen</strong> paradigm makes all of this more sound
in my opinion, because putting <em>relations</em> together is much easier than
putting <em>SQL queries</em> together (cfr. <a href="#struggling">the <em>join</em> example</a> in the
previous section). The semantics of &quot;putting together&quot; is more straightforward
in the former case, that&#39;s all. An algebra <em>is</em> about providing operators for
putting operands together, a calculus simply is not. Approaches such as Alf&#39;s
is no less expressive, quite the contrary. For instance, expressing a SQL
<code>WHERE NOT EXISTS</code> is kind of <a href="http://stackoverflow.com/questions/7152424/rails-3-arel-for-not-exists">a
nightmare</a>
with existing approaches, and almost impossible to do in a modular way due to
the coupling between the main query and the sub-query:</p>
<div class="highlight"><pre><span class="c1"># Show suppliers that supply no part at all (Sequel)</span>
<span class="no">DB</span><span class="o">[</span><span class="ss">:suppliers___s</span><span class="o">].</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="no">DB</span><span class="o">[</span><span class="ss">:supplies___sp</span><span class="o">].</span><span class="n">where</span><span class="p">(</span><span class="no">Sequel</span><span class="o">.</span><span class="n">qualify</span><span class="p">(</span><span class="ss">:sp</span><span class="p">,</span> <span class="ss">:sid</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="no">Sequel</span><span class="o">.</span><span class="n">qualify</span><span class="p">(</span><span class="ss">:s</span><span class="p">,</span> <span class="ss">:sid</span><span class="p">)))</span><span class="o">.</span><span class="n">exists</span><span class="p">)</span>
</pre>
</div>

<p>It is dead simple in Alf (and here, you can thank <a
href="http://en.wikipedia.org/wiki/D_(data_language_specification)"
target="_blank"><b>Tutorial D</b></a>, where this operator comes from):</p>
<div class="highlight"><pre><span class="c1"># Show suppliers that supply no part at all (Alf)</span>
<span class="n">not_matching</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">supplies</span><span class="p">)</span>
</pre>
</div>

<div class="try-this"><a href="/?src=IyBTaG93IHN1cHBsaWVycyB0aGF0IHN1cHBseSBubyBwYXJ0IGF0IGFsbCAo
QWxmKQpub3RfbWF0Y2hpbmcoc3VwcGxpZXJzLCBzdXBwbGllcyk=
" target="_blank">Try it!</a></div>

<p>Now, relational calculus and relation algebra are known to be equivalent in
expressive power. This is what allows Alf to compile queries in the second
form above to something similar to the former one and to send it to an
underlying SQL DBMS. The feature is limited by the ability to reconcile the
Ruby and SQL type systems though, something I will discuss in the next
section.</p>

<h3 id="what-type-system">From SQL's to Host's Type System</h3>

<p>There is another very important change I have not discussed so far regarding
the proposed <strong>Relations as First-Class Citizen</strong> paradigm. In essence, it is
a challenging proposal (from an implementation point of view at least): <em>why
not abstracting from SQL completely?</em></p>

<p><em>Aside: this section applies to Alf but, as far as I know, not to Axiom.</em></p>

<p>Indeed, almost all approaches (even ORMs) do actually espouse SQL in a very
rigid way. An obvious example is that the developer is almost never allowed to
express filtering conditions or to perform computations that are not supported
by SQL in the first place. It is unfortunate, because SQL&#39;s type system is
old, and poor (few support for user-defined types, for instance). How about
providing a query interface that actually espouse the host type system, i.e.
the one of the host programming language (here, Ruby)?</p>

<p>Want to express a filtering condition involving a ruby regular expression? No
problem:</p>
<div class="highlight"><pre><span class="c1"># Get suppliers whose name contains a &#39;J&#39; or a &#39;B&#39;</span>
<span class="n">restrict</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">){</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">=~</span> <span class="sr">/J|B/</span> <span class="p">})</span>
</pre>
</div>

<div class="try-this"><a href="/?src=IyBHZXQgc3VwcGxpZXJzIHdob3NlIG5hbWUgY29udGFpbnMgYSAnSicgb3Ig
YSAnQicKcmVzdHJpY3Qoc3VwcGxpZXJzLCAtPih0KXsgdC5uYW1lID1+IC9K
fEIvIH0p
" target="_blank">Try it!</a></div>

<p>Want to compute an array-valued attribute (or even use you own user-defined
data type/class)? No problem:</p>
<div class="highlight"><pre><span class="c1"># Get suppliers and the letters of their name in uppercase</span>
<span class="kp">extend</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">letters</span><span class="p">:</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">){</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upcase</span><span class="o">.</span><span class="n">chars</span><span class="o">.</span><span class="n">to_a</span> <span class="p">})</span>
</pre>
</div>

<div class="try-this"><a href="/?src=IyBHZXQgc3VwcGxpZXJzIGFuZCB0aGUgbGV0dGVycyBvZiB0aGVpciBuYW1l
IGluIHVwcGVyY2FzZQpleHRlbmQoc3VwcGxpZXJzLCBsZXR0ZXJzOiAtPih0
KXsgdC5uYW1lLnVwY2FzZS5jaGFycy50b19hIH0p
" target="_blank">Try it!</a></div>

<p>Want to group tuples as sub-relations? There is even an operator for that:</p>
<div class="highlight"><pre><span class="c1"># Get suppliers grouped by city</span>
<span class="n">group</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="o">[</span><span class="ss">:sid</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:status</span><span class="o">]</span><span class="p">,</span> <span class="ss">:suppliers</span><span class="p">)</span>
</pre>
</div>

<div class="try-this"><a href="/?src=IyBHZXQgc3VwcGxpZXJzIGdyb3VwZWQgYnkgY2l0eQpncm91cChzdXBwbGll
cnMsIFs6c2lkLCA6bmFtZSwgOnN0YXR1c10sIDpzdXBwbGllcnMp
" target="_blank">Try it!</a></div>

<p>This might look at simply providing a consistent interface for working with
relations. Absolutely, that&#39;s the point. You can mix everything, composing
queries in the idiomatic way. In the example below, Alf compiles the &#39;Paris&#39;
restriction to SQL while it computes the &#39;letters&#39; extension itself (see the
optimizer and query plans), even if the extension comes <em>before</em> the
restriction:</p>
<div class="highlight"><pre><span class="n">rel</span> <span class="o">=</span> <span class="kp">extend</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">letters</span><span class="p">:</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">){</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upcase</span><span class="o">.</span><span class="n">chars</span><span class="o">.</span><span class="n">to_a</span> <span class="p">})</span>
<span class="n">rel</span> <span class="o">=</span> <span class="n">restrict</span><span class="p">(</span><span class="n">rel</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="s1">&#39;Paris&#39;</span><span class="p">)</span>
</pre>
</div>

<div class="try-this"><a href="/?src=cmVsID0gZXh0ZW5kKHN1cHBsaWVycywgbGV0dGVyczogLT4odCl7IHQubmFt
ZS51cGNhc2UuY2hhcnMudG9fYSB9KQpyZWwgPSByZXN0cmljdChyZWwsIGNp
dHk6ICdQYXJpcycp
" target="_blank">Try it!</a></div>

<p>Now think about it. This amounts at <em>abstracting</em> from SQL and letting
developers think in terms of their <em>usual</em> type system. While powerful, this
is very challenging (but fun) in practice for the implementer (i.e. for me)
and comes at a cost (for you). There are drawbacks and limitations that you
must be aware of (I&#39;ll come back to this point in the next section). That
means that you can&#39;t abstract from reality entirely after all, as often with
abstractions, but yet more than with existing approaches in my opinion.</p>

<h3 id="why-not-classes-and-objects">From One-At-a-Time to Set-At-a-Time</h3>

<p>This point is very important, since it introduces a significant difference
with Object-Relational Mapping. I haven&#39;t talked much about ORM so far, but
it&#39;s true that <strong>Relations as First-Class Citizen</strong> is better compared to
<strong>Object-Relational Mapping</strong> (ORM) than to libraries such as <code>Sequel</code>. Both
are paradigms that present data to the software in a particular way, and
provide an abstraction mechanism <em>above</em> SQL. (I take this opportunity to put
a bit of fairness back into the picture. This is especially important for me
since Alf itself currently relies on <code>Sequel</code> to generate cross-DBMS SQL code
in a very easy way.)</p>

<p>Object-Relational Mapping relies on the availability of an Object Model, that
aims at capturing the (structual) domain. Doing so is one interpretation of what
<a href="http://books.google.be/books?id=hHBf4YxMnWMC&amp;printsec=frontcover&amp;source=gbs_ge_summary_r&amp;cad=0#v=onepage&amp;q&amp;f=false">Domain Driven Design</a>
(DDD) is about, more accurately one implementation strategy of DDD. I&#39;m not
convinced it&#39;s the good one, but it&#39;s definitely one of them. There are at
least two reasons why I&#39;m not convinced.</p>

<p>First, modeling the (data) domain is certainly not the same as designing a
software for meeting requirements in that domain (whatever that means). The
fact that you&#39;ve drawn O-O diagrams (even if it&#39;s in your head) capturing the
domain entities, their relationships and interactions is not sufficient for
stating that the software implementation must be a copy-paste of those
diagrams. Most of the time, the software <em>supports</em> the domain; it does rarely
<em>implement</em> or <em>simulate</em> it. Models are there to guide your <em>understanding</em>
of the domain, not to <em>be</em> the implementation of your requirements. Subtle
difference (abstract one, I&#39;m affraid), but important.</p>

<p>The second reason is more directly relevant to the proposed paradigm and Alf.
Suppose a <code>Supplier</code> class in your O-O software. What does that class capture?
Well, from a modeling point of view it captures the fact that <code>supplier</code> is
a relevant concept/entity in the domain. From the software point of view,
it captures an irrelevant set, and lots of individuals of (marginal?) interest:</p>

<ul>
<li>The <code>Supplier</code> class captures the set of all possible suppliers, that is,
all possible supplier instances that you can represent in software memory by
invoking the class constructor. Observe that you can&#39;t do anything relevant
with this set with respect to your actual requirements, except maybe
&quot;selecting&quot; a particular individual.</li>
<li>Those individuals are of course not the <em>real</em> suppliers, but only
<em>information about</em> them or a <em>representation of</em> them in the software. I
invite you to read <a href="http://www.revision-zero.org/orm-haters-do-get-it">a previous writing of
mine</a> to understand why I
think that manipulating information through individuals is just wrong.</li>
</ul>

<p>I won&#39;t repeat those arguments here. Let me instead simply state a few
requirements in our hypothetic suppliers and parts software, while
highlighting relevant parts for the discussion at hand:</p>

<ul>
<li>A supplier may only see information about <strong>the suppliers located in the same
city than himself</strong>,</li>
<li>The GUI shall display <strong>relevant information about the supplier such as her
name, city and country</strong>.</li>
<li>The GUI shall never expose <strong>supplier statuses</strong>, except to
<strong>administrators</strong>, that is, <strong>suppliers with a status greater than 30</strong>.</li>
<li>The software should periodically send an email to <strong>all suppliers who supply
less than 5 parts</strong> to ...</li>
<li>The administration interface shall display <strong>performance indicators</strong> such as
the <strong>number of registered suppliers per city</strong>, ...</li>
<li>and so on.</li>
</ul>

<p>Hence the following question. Why does our source code provide such a huge
visibility to completely irrelevant sets, e.g. the <code>Supplier</code> class, instead
of promoting those relevant sets above as first class citizen? Hence the name
of the paradigm, <strong>Relations as First-Class Citizen</strong>, because relations
better capture those sets than O-O classes:</p>
<div class="highlight"><pre><span class="kp">extend</span><span class="p">(</span><span class="no">DEE</span><span class="p">,</span>
  <span class="c1"># the suppliers located in the same city than himself (say S3)</span>
  <span class="n">visible</span><span class="p">:</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">){</span>
    <span class="n">matching</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">project</span><span class="p">(</span><span class="n">restrict</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">sid</span><span class="p">:</span> <span class="s1">&#39;S3&#39;</span><span class="p">),</span> <span class="o">[</span><span class="ss">:city</span><span class="o">]</span><span class="p">))</span> 
  <span class="p">},</span>
  <span class="c1"># administrators, i.e. suppliers with a status greater than 30</span>
  <span class="n">administrators</span><span class="p">:</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">){</span>
    <span class="n">restrict</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">gte</span><span class="p">(</span><span class="ss">:status</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
  <span class="p">},</span>
  <span class="c1"># registered suppliers</span>
  <span class="n">registered</span><span class="p">:</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">){</span>
    <span class="n">suppliers</span>
  <span class="p">})</span>
</pre>
</div>

<div class="try-this"><a href="/?src=ZXh0ZW5kKERFRSwKICAjIHRoZSBzdXBwbGllcnMgbG9jYXRlZCBpbiB0aGUg
c2FtZSBjaXR5IHRoYW4gaGltc2VsZiAoc2F5IFMzKQogIHZpc2libGU6IC0+
KHQpewogICAgbWF0Y2hpbmcoc3VwcGxpZXJzLCBwcm9qZWN0KHJlc3RyaWN0
KHN1cHBsaWVycywgc2lkOiAnUzMnKSwgWzpjaXR5XSkpIAogIH0sCiAgIyBh
ZG1pbmlzdHJhdG9ycywgaS5lLiBzdXBwbGllcnMgd2l0aCBhIHN0YXR1cyBn
cmVhdGVyIHRoYW4gMzAKICBhZG1pbmlzdHJhdG9yczogLT4odCl7CiAgICBy
ZXN0cmljdChzdXBwbGllcnMsIGd0ZSg6c3RhdHVzLCAzMCkpCiAgfSwKICAj
IHJlZ2lzdGVyZWQgc3VwcGxpZXJzCiAgcmVnaXN0ZXJlZDogLT4odCl7CiAg
ICBzdXBwbGllcnMKICB9KQ==
" target="_blank">Try it!</a></div>

<p>(Note that the example above does not aim at illustrating an actual
user-friendly syntax or idiomatic way of implementing the kind of features I&#39;m
discussing here. It shows, in contrast, that all those relations can be
captured rather easily, even all at once; try it).</p>

<p>ORMs such as Active Record provide so-called
<a target="_blank" href="http://guides.rubyonrails.org/active_record_querying.html#scopes">scopes</a>
that may be argued providing what I ask here (possibly with a better syntax,
by the way):</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Supplier</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">scope</span> <span class="ss">:administrator</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="s2">&quot;status &gt; 30&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</pre>
</div>

<p>Two main important differences exist, though:</p>

<ul>
<li>First, observe that in Active Record, <code>Supplier</code> and
<code>Supplier.administrator</code> do not denote similar things. The first one is a
<code>Class</code>, the second is an <code>ActiveRecord::Relation</code> and you can&#39;t substitute
one for the other. In addition, scopes are subordinated to classes, making
them second-class, not first-class citizen.</li>
<li><p>Second, scopes do not allow deriving new first-class concepts. They mostly
allow filtering existing ones (loosely speaking). For instance, you&#39;ll have
a hard time trying to promote the concept below as first-class with scopes.
Indeed, it would require creating &quot;derived classes&quot;, whatever this is
supposed to mean in practice:</p>
<div class="highlight"><pre>  <span class="c1"># performance indicators, e.g. registered suppliers per city</span>
  <span class="n">indicators</span> <span class="o">=</span> <span class="n">summarize</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="o">[</span><span class="ss">:city</span><span class="o">]</span><span class="p">,</span> <span class="n">nb</span><span class="p">:</span> <span class="n">count</span><span class="p">())</span>

  <span class="c1"># first-class means you can use it as any other concept</span>
  <span class="n">restrict</span><span class="p">(</span><span class="n">indicators</span><span class="p">,</span> <span class="n">gt</span><span class="p">(</span><span class="ss">:nb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre>
</div>

<div class="try-this"><a href="/?src=IyBwZXJmb3JtYW5jZSBpbmRpY2F0b3JzLCBlLmcuIHJlZ2lzdGVyZWQgc3Vw
cGxpZXJzIHBlciBjaXR5CmluZGljYXRvcnMgPSBzdW1tYXJpemUoc3VwcGxp
ZXJzLCBbOmNpdHldLCBuYjogY291bnQoKSkKCiMgZmlyc3QtY2xhc3MgbWVh
bnMgeW91IGNhbiB1c2UgaXQgYXMgYW55IG90aGVyIGNvbmNlcHQKcmVzdHJp
Y3QoaW5kaWNhdG9ycywgZ3QoOm5iLCAxKSk=
" target="_blank">Try it!</a></div></li>
</ul>

<p>To summarize (sorry if it seems offensive, I&#39;d better like to be
thought-provoking instead): ORMs promote irrelevant sets as first-class and a
subset of relevant ones as second-class, subordinated to the former. Isn&#39;t
that <em>very</em> strange? In addition, ORMs promote a &quot;design around structural
concepts&quot; kind of programming style, where good object-oriented design focuses
on behaviors instead.</p>

<p>Now, Alf provides a good foundation for <strong>Relations as First-Class Citizen</strong>,
but it does not completely reach that point so far. Indeed, it provides a way
to compute any relation and use it consistently. To implement the paradigm
completely, however, it would also need to provide a way to &#39;promote&#39; the
relations that makes more sense in the domain as <em>special</em> citizen in the
software design. I&#39;ll say a word about domain-specific relational operators
and database viewpoints in the next section, which are good attempts to reach
this but require more work.</p>

<h2 id="ongoing-work">Limitations and ongoing work</h2>

<p>The approach proposed here opens an avenue for further optimization,
experimentation and research. I close this blog post with an overview of my
own ongoing work in this area (which are all subjects I will be talking about
here in the near future). I also draw the reader&#39;s attention on Alf&#39;s current
limitations.</p>

<h3>Towards high-level, domain-specific relational operators</h3>

<p>The closure property of relational algebra opens the ability to define new
relational operators in a very simple way, provided they are shortcuts over
longer expressions. Alf comes with such a facility, as illustrated below:</p>
<div class="highlight"><pre><span class="c1"># It relation `test` contains at least one tuple return `then_relation`,</span>
<span class="c1"># otherwise return `else_relation`</span>
<span class="k">def</span> <span class="nf">ite</span><span class="p">(</span><span class="nb">test</span><span class="p">,</span> <span class="n">then_relation</span><span class="p">,</span> <span class="n">else_relation</span><span class="p">)</span>
  <span class="n">union</span><span class="p">(</span>
    <span class="n">matching</span><span class="p">(</span><span class="n">then_relation</span><span class="p">,</span> <span class="n">project</span><span class="p">(</span><span class="nb">test</span><span class="p">,</span> <span class="o">[]</span><span class="p">)),</span>
    <span class="n">not_matching</span><span class="p">(</span><span class="n">else_relation</span><span class="p">,</span> <span class="n">project</span><span class="p">(</span><span class="nb">test</span><span class="p">,</span> <span class="o">[]</span><span class="p">)))</span>
<span class="k">end</span>

<span class="c1"># It there are at least one Red part, show suppliers in London, otherwise</span>
<span class="c1"># show suppliers in Paris</span>
<span class="n">ite</span><span class="p">(</span>
  <span class="n">restrict</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="s1">&#39;Red&#39;</span><span class="p">),</span>
  <span class="n">restrict</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="s1">&#39;London&#39;</span><span class="p">),</span>
  <span class="n">restrict</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="s1">&#39;Paris&#39;</span><span class="p">))</span>
</pre>
</div>

<div class="try-this"><a href="/?src=IyBJdCByZWxhdGlvbiBgdGVzdGAgY29udGFpbnMgYXQgbGVhc3Qgb25lIHR1
cGxlIHJldHVybiBgdGhlbl9yZWxhdGlvbmAsCiMgb3RoZXJ3aXNlIHJldHVy
biBgZWxzZV9yZWxhdGlvbmAKZGVmIGl0ZSh0ZXN0LCB0aGVuX3JlbGF0aW9u
LCBlbHNlX3JlbGF0aW9uKQogIHVuaW9uKAogICAgbWF0Y2hpbmcodGhlbl9y
ZWxhdGlvbiwgcHJvamVjdCh0ZXN0LCBbXSkpLAogICAgbm90X21hdGNoaW5n
KGVsc2VfcmVsYXRpb24sIHByb2plY3QodGVzdCwgW10pKSkKZW5kCgojIEl0
IHRoZXJlIGFyZSBhdCBsZWFzdCBvbmUgUmVkIHBhcnQsIHNob3cgc3VwcGxp
ZXJzIGluIExvbmRvbiwgb3RoZXJ3aXNlCiMgc2hvdyBzdXBwbGllcnMgaW4g
UGFyaXMKaXRlKAogIHJlc3RyaWN0KHBhcnRzLCBjb2xvcjogJ1JlZCcpLAog
IHJlc3RyaWN0KHN1cHBsaWVycywgY2l0eTogJ0xvbmRvbicpLAogIHJlc3Ry
aWN0KHN1cHBsaWVycywgY2l0eTogJ1BhcmlzJykp
" target="_blank">Try it!</a></div>

<p>While the example above is contrived, our experience suggests that the <code>ite</code>
relational operator proves very useful in practice when dealing with complex
data visibility and privacy requirements. Interesting enough, you can check
that the compilation involves only one SQL query sent to the underlying DBMS,
resulting in important performance improvements compared to other approaches
relying on an <code>if/then/else</code> statement in the host language (especially when
the latter is much slower than the DBMS engine itself, e.g. Ruby vs. a DBMS
engine implemented in C).</p>

<p>Similarly, even when involving complex data types and collections, most query
plans involve a <em>constant</em> number of SQL queries, avoiding the &#39;N+1 queries&#39;
trap <a href="http://stackoverflow.com/questions/97197/what-is-the-n1-selects-issue">infamously
known</a>
with Object-Relational Mappers:</p>
<div class="highlight"><pre><span class="n">join</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">group</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">supplies</span><span class="p">,</span> <span class="n">parts</span><span class="p">),</span> <span class="o">[</span><span class="ss">:sid</span><span class="o">]</span><span class="p">,</span> <span class="ss">:supplied_parts</span><span class="p">,</span> <span class="n">allbut</span><span class="p">:</span> <span class="kp">true</span><span class="p">))</span>
</pre>
</div>

<div class="try-this"><a href="/?src=am9pbihzdXBwbGllcnMsIGdyb3VwKGpvaW4oc3VwcGxpZXMsIHBhcnRzKSwg
WzpzaWRdLCA6c3VwcGxpZWRfcGFydHMsIGFsbGJ1dDogdHJ1ZSkp
" target="_blank">Try it!</a></div>

<p>Alf already has a few high-level operators such as <a href="/doc/api/matching">matching</a>
or <a href="/doc/api/page">page</a>. The next release should include a few others currently
evaluated on case studies: <code>ite</code>, <code>image</code>, <code>abstract</code>, <code>dive</code>, <code>quota</code>, etc.</p>

<h3>Database viewpoints</h3>

<p>The closure property of relational algebra also opens the ability to define
composable database viewpoints. Viewpoints provide a very effective
abstraction mechanism for implementing complex security/privacy requirements,
as well as providing context-aware database interfaces.</p>

<p>Without entering the details here, the following example illustrates the
approach by hacking on Ruby&#39;s <code>super</code> mechanism. Suppose we want to provide a
database viewpoint on suppliers and parts located in London:</p>
<div class="highlight"><pre><span class="c1"># Start of the viewpoint</span>
<span class="k">def</span> <span class="nf">suppliers</span>
  <span class="n">restrict</span><span class="p">(</span><span class="k">super</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="s1">&#39;London&#39;</span><span class="p">)</span>
<span class="k">end</span>
<span class="k">def</span> <span class="nf">parts</span>
  <span class="n">restrict</span><span class="p">(</span><span class="k">super</span><span class="p">,</span> <span class="n">city</span><span class="p">:</span> <span class="s1">&#39;London&#39;</span><span class="p">)</span>
<span class="k">end</span>
<span class="k">def</span> <span class="nf">supplies</span>
  <span class="c1"># restore foreign keys given the previous restrictions</span>
  <span class="n">matching</span><span class="p">(</span><span class="n">matching</span><span class="p">(</span><span class="k">super</span><span class="p">,</span> <span class="n">parts</span><span class="p">),</span> <span class="n">suppliers</span><span class="p">)</span>
<span class="k">end</span>
<span class="c1"># End of the viewpoint</span>

<span class="c1"># Query as usual. This is entirely transparent.</span>
<span class="c1"># Check it yourself, supplier S2 no longer exists in this viewpoint.</span>
<span class="n">restrict</span><span class="p">(</span><span class="n">supplies</span><span class="p">,</span> <span class="n">sid</span><span class="p">:</span> <span class="s1">&#39;S1&#39;</span><span class="p">)</span>
</pre>
</div>

<div class="try-this"><a href="/?src=IyBTdGFydCBvZiB0aGUgdmlld3BvaW50CmRlZiBzdXBwbGllcnMKICByZXN0
cmljdChzdXBlciwgY2l0eTogJ0xvbmRvbicpCmVuZApkZWYgcGFydHMKICBy
ZXN0cmljdChzdXBlciwgY2l0eTogJ0xvbmRvbicpCmVuZApkZWYgc3VwcGxp
ZXMKICAjIHJlc3RvcmUgZm9yZWlnbiBrZXlzIGdpdmVuIHRoZSBwcmV2aW91
cyByZXN0cmljdGlvbnMKICBtYXRjaGluZyhtYXRjaGluZyhzdXBlciwgcGFy
dHMpLCBzdXBwbGllcnMpCmVuZAojIEVuZCBvZiB0aGUgdmlld3BvaW50Cgoj
IFF1ZXJ5IGFzIHVzdWFsLiBUaGlzIGlzIGVudGlyZWx5IHRyYW5zcGFyZW50
LgojIENoZWNrIGl0IHlvdXJzZWxmLCBzdXBwbGllciBTMiBubyBsb25nZXIg
ZXhpc3RzIGluIHRoaXMgdmlld3BvaW50LgpyZXN0cmljdChzdXBwbGllcywg
c2lkOiAnUzEnKQ==
" target="_blank">Try it!</a></div>

<p>Database viewpoints are currently read-only in Alf. I intentionnally left the
question of database updates aside in this blog post. Alf comes only with a
very experimental interface for updates (cfr. <a href="/doc/pages/alf-in-ruby">Alf in Ruby</a>)
but a lot of work is still needed in this area.</p>

<h3>Reconciling heterogeneous type systems</h3>

<p>As already suggested, abstracting from SQL is challenging for the implementer.
More specifically, abstracting from SQL <em>and</em> guaranteeing soundness and
efficiency at the same time are conflicting requirements. Alf has a smart
compiler that delegates to underlying engines what can be delegated, but the
explicit use of the host type system is a showstopper during compilation. To
better understand this, consider the following query:</p>
<div class="highlight"><pre><span class="n">restrict</span><span class="p">(</span>
  <span class="kp">extend</span><span class="p">(</span><span class="n">suppliers</span><span class="p">,</span> <span class="n">uppercased</span><span class="p">:</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">){</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upcase</span> <span class="p">}),</span>
  <span class="n">city</span><span class="p">:</span> <span class="s1">&#39;Paris&#39;</span><span class="p">,</span> <span class="n">uppercased</span><span class="p">:</span> <span class="s1">&#39;JONES&#39;</span><span class="p">)</span>
</pre>
</div>

<div class="try-this"><a href="/?src=cmVzdHJpY3QoCiAgZXh0ZW5kKHN1cHBsaWVycywgdXBwZXJjYXNlZDogLT4o
dCl7IHQubmFtZS51cGNhc2UgfSksCiAgY2l0eTogJ1BhcmlzJywgdXBwZXJj
YXNlZDogJ0pPTkVTJyk=
" target="_blank">Try it!</a></div>

<p>If you take a look at the query plan, you&#39;ll observe that the <code>restrict</code>
invocation is only partially compiled to SQL. The <code>uppercased</code> attribute is
computed by Alf in Ruby and cannot be translated back to the SQL engine. This
has serious performance implications, of course. As of current Alf version,
this is the case as soon as you use a ruby block (e.g. <code>->(t){ ... }</code>).</p>

<p>All other approaches I&#39;m aware of either have a similar problem or forbid
such queries in the first place (and are hence less expressive). This calls
for further symbiosis and interoperability between heterogeneous type systems
(SQL and Ruby in the present case).</p>

<h2 id="conclusion">Conclusion</h2>

<p>Arrived here? Kudos. To summarize, I&#39;m convinced that <strong>Relations as
First-class citizen</strong> provides better abstractions than existing approaches
for software-database interoperability, or more generally, for handling the
data manipulation subset of our software engineering requirements. In
particular, I hope to have shown how current database connectivity approaches
hurt separation of concerns and reuse (more generally, software design) and
why favoring pure relational algebra over (idiomatic) SQL helps avoiding the
trap.</p>

<p>As I&#39;ve discussed, Alf itself needs more work to truly embrace the paradigm,
as that goes further that simply providing an algebraic query language. Stay
tuned, I&#39;ll provide more material and writings about how to use Alf in more
complex software (such as the viewpoints stuff). In the mean time, any
question or contribution (of any kind) can be adressed by sending an email to
Bernard Lambeau (see the <a href="/about/">About</a> page; I&#39;m easily found on the
Internet too). I&#39;m currently looking for contributors both in the academics
and in the industrial world for discussing, enhancing, testing and evaluating
the approach, don&#39;t hesitate to contact me by email.</p>

<h2>Acknowledgements</h2>

<p>I&#39;d like to thank Sergio C., Erwin S., Enrico S., David L., Magnus H., Kim M.
and Louis L. for their feedback and comments on earlier versions of this blog
post.</p>
