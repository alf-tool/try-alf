{"predicates":[{"name":"among","synopsis":"Among a set of values","description":"This predicates checks whether `val` belongs to the set of values `vals`.","notes":"The set `vals` may only contain pure values, attribute names are not\nsupported. Any enumerable of such values is supported in practice, e.g.\nan Array literal.","signature":"val: Alpha|AttrName, vals: Set<Alpha>","examples":["among(:status, [10, 30])"]},{"name":"between","synopsis":"Between (inclusive)","description":"This predicates checks whether a value (`val`) is between two bounds `min`\nand `max`, inclusive on both sides.","notes":"This predicate is equivalent to `gte(_val_,_min_) & lte(_val_,_max_)`.","signature":"val: Alpha|AttrName, min: Alpha|AttrName, max: Alpha|AttrName","examples":["between(:status, 10, 30)"]},{"name":"contradiction","synopsis":"FALSE","description":"This predicate always return false. It is equivalent to `->(t){ false }`.","notes":"","signature":"","examples":["false","contradiction"]},{"name":"eq","synopsis":"Equals to","description":"This predicates checks whether two values are equal.","notes":"This predicate is equivalent to `->(t){ _left_ == _right_ }`.","signature":"left: Alpha|AttrName, right: Alpha|AttrName","examples":["eq(:city, 'London')","eq(:supplier_city, :part_city)"]},{"name":"gt","synopsis":"Greater than","description":"This predicates checks whether a value (`left`) is greater than another\none (`right`).","notes":"This predicate is equivalent to `->(t){ _left_ > _right_ }`.","signature":"left: Alpha|AttrName, right: Alpha|AttrName","examples":["gt(:status, 20)","gt(:status, 30)"]},{"name":"gte","synopsis":"Greater than or equal to","description":"This predicates checks whether a value (`left`) is greater than or equal\nto another one (`right`).","notes":"This predicate is equivalent to `->(t){ _left_ >= _right_ }`.","signature":"left: Alpha|AttrName, right: Alpha|AttrName","examples":["gte(:status, 20)","gte(:status, 30)"]},{"name":"lt","synopsis":"Less than","description":"This predicates checks whether a value (`left`) is less than another one\n(`right`).","notes":"This predicate is equivalent to `->(t){ _left_ < _right_ }`.","signature":"left: Alpha|AttrName, right: Alpha|AttrName","examples":["lt(:status, 20)","lt(:status, 30)"]},{"name":"lte","synopsis":"Less than or equal to","description":"This predicates checks whether a value (`left`) is less than or equal to\nanother one (`right`).","notes":"This predicate is equivalent to `->(t){ _left_ <= _right_ }`.","signature":"left: Alpha|AttrName, right: Alpha|AttrName","examples":["lte(:status, 20)","lte(:status, 30)"]},{"name":"native","synopsis":"User-defined tuple predicate","description":"So called 'native' predicates are functions computing truth values from\ntuples.","notes":"Native predicates can be any ruby Proc object of arity 1. The argument\nwill be a Tuple instance. the Proc SHOULD return true or false, but ruby\npatterns for boolean expressions are supported to (such a nil evaluating\nto false, etc.).\n\nNote that, as of current Alf version, native predicates cannot be delegated\nto an underlying data engine, and are not compiled to SQL in particular.\nPlease always use predicate factories such as `eq(:city, 'London')` if\npossible, as they do not hurt logical optimizations and compilation.","signature":"predicate: (Tuple -> Boolean)","examples":["->(t){ t.city == 'London' }"]},{"name":"neq","synopsis":"Not equal to","description":"This predicates checks whether two values are different.","notes":"This predicate is equivalent to `->(t){ _left_ != _right_ }`.","signature":"left: Alpha|AttrName, right: Alpha|AttrName","examples":["neq(:city, 'London')","neq(:supplier_city, :part_city)"]},{"name":"tautology","synopsis":"TRUE","description":"This predicate always return true. It is equivalent to `->(t){ true }`.","notes":"","signature":"","examples":["true","tautology"]}]
,"operators":[{"name":"allbut","synopsis":"Projects a subset of attributes away.","description":"Computes the relation obtained by removing a subset of attributes from\n`operand` tuples.\n\nThis operator is the inverse of `project`. While the latter _keeps_\nattributes, this one _removes_ them. `project` actually supports an allbut\nvariant, which is equivalent to this operator. In other words, this\noperator can be understood as follows:\n\n```try\ndef allbut(operand, attributes)\n  project(operand, attributes, allbut: true)\nend\nallbut(suppliers, [:city, :status])\n```","notes":"Unlike SQL, this operator ALWAYS remove duplicates. There is no way, in\nAlf, to compute _bags_ of tuples.","signature":"operand: Relation, attributes: AttrList","options":"allbut: Boolean","examples":["allbut(suppliers, [:city])"]},{"name":"extend","synopsis":"Extends input tuples with derived/computed attributes","description":"Computes a relation which is the same as `operand`, except that each of\nits tuples has new attributes whose value is the result of evaluating the\ntuple expressions specified in `ext`.","notes":"As of current Alf version, this operator cannot be translated to SQL code.\nIn other words, all computations are done in ruby, which may seriously\nhurt performance.\n\nSimilarly, as `extend` tends to be a showstopper during compilation, it is\nstrongly recommanded to use it as high as possible in query expressions\ntrees so as to delegate the largest possible query parts to data engines.","signature":"operand: Relation, ext: TupleComputation","options":"","examples":["extend(suppliers,\n  big:   ->(t){ t.name.upcase },\n  small: ->(t){ t.name.downcase })"]},{"name":"frame","synopsis":"Aka limit/offset","description":"Computes a relation by restricting the tuples of `operand` to a particular\nframe. This frame can be easily remembered through the \"skip `offset`,\ntake `limit`\" mnemonic mean, provided `order` is a total order.\n\nFormally, the frame is defined by those tuples whose ranking according to\n`order` is such that `offset <= rank < limit`. In other words, this\noperator is actually equivalent to the following definition:\n\n```try\ndef frame(operand, order, offset, limit)\n  allbut(\n    restrict(\n      rank(operand, order, :rank),\n      lte(offset, :rank) & lt(:rank, offset+limit)),\n    [:rank])\nend\nframe(suppliers, [:city, :sid], 2, 3)\n```\n\nAs of current Alf version, for this operator to be semantically sound and\ndeterministic, `order` MUST be a total order, that is, it must at least\ncover a candidate key. As of current Alf version, no error is raised if\nthis is not the case but that might change in future versions.","notes":"Contrary to the longer expression shown above, this operator compiles to\n'efficient' SQL (rank does not, so far) at the cost of having to provide a\ntotal order.\n\nAs the result is a relation and relations are not ordered by definition,\nthe order in which tuples can be observed in the result (e.g. through\nexplicit tuple iteration, casting to an array, json encoding) is NOT\nguaranteed to follow `order`.","signature":"operand: Relation, order: Ordering, offset: Integer, limit: Integer","options":"","examples":["frame(suppliers, [:status, :sid], 0, 3)","frame(suppliers, [[:status, :asc], [:sid, :desc]], 1, 2)"]},{"name":"group","synopsis":"Relation-valued attribute","description":"Summarizes `operand` by all but the specified `attributes` and groups the\nlatter under a relation-value attribute `as`.\n\nThis operator could be formally defined as the following shortcut:\n\n```try\ndef group(operand, attributes, as)\n  extend(\n    allbut(operand, attributes),\n    as: ->(t){ project(matching(operand, Relation(t)), attributes) })\nend\ngroup(suppliers, [:sid, :name, :status], :suppliers)\n```\n\nThis operators supports an ALL BUT variant, through the `allbut` option.\nWhen set to true, the operator keeps specified attributes and groups all\nremaining ones as a relation-valued attribute.","notes":"This operator does not compile to SQL so far. Contributions are welcome\nto provide it with a SQL compilation for SQL DBMSs that support this kind\nof feature (e.g. PostgreSQL with JSON data type)","signature":"operand: Relation, attributes: AttrList, as: AttrName","options":"allbut: Boolean","examples":["group(suppliers, [:sid, :name, :status], :suppliers)","group(suppliers, [:city], :suppliers, allbut: true)"]},{"name":"image","synopsis":"Extend the left operand with a new relation-valued attribute, image of the\ntuple in the right relation.","description":"This operator extends each tuple (say `t`) of the left operand with a new\nattribute called `as`. The latter is a relation-valued attribute, and is the\nimage of `t` with respect to the right relation. The image is defined as a\nrestriction-projection: restriction on tuples that match `t` and projection\non all but common attributes between left and right.\n\nIn other words, this operator is a shortcut for the following longer\nexpression:\n\n```try\ndef image(left, right, as)\n  extend(left, as => ->(t){\n    allbut(\n      matching(right, Relation(t)),\n      left.attr_list & right.attr_list)\n  })\nend\nimage(suppliers, supplies, :supplying)\n```\n\nNote that the image operator is such that every tuple of the left operand\nappears in the result, including those whose image is empty on right. As\nexpected, an empty relation of correct relation type is used for those.","notes":"As of current Alf version, the current SQL compilation is not optimal and\npartly relies on in-memory operations. Please check the compilation plans.","signature":"left: Relation, right: Relation, as: AttrName","options":"","examples":["image(suppliers, supplies, :supplying)"]},{"name":"intersect","synopsis":"Logical AND","description":"Computes the relation as the set intersection of `left` and `right`.\n\nThe `left` and `right` relations must be intersect-compatible, meaning that\nthey must have same heading (type inheritance is partly supported through\nruby's own type system, so that the actual behavior is slighlty more\npermissive).","notes":"Unlike SQL, this operator ALWAYS remove duplicates. There is no way, in\nAlf, to compute _bags_ of tuples and therefore no way to express something\nsuch as SQL's INTERSECT ALL.\n\nIt is sometimes idiomatic in Alf to use `intersect` as a logical AND, as\nillustrated below. So far, the optimizer/compiler is not smart enough to\ntranslate the former into the latter (which is likely to have a better query\nwhen using faithful SQL compilation and available SQL DBMSs). Any patch is\nwelcome here too!\n\n```try\nintersect(\n  restrict(suppliers, eq(:city, 'Paris')),\n  restrict(suppliers, gt(:status, 10)))\n```\n\nis equivalent to\n\n```try\nrestrict(suppliers, eq(:city, 'Paris') & gt(:status, 10))\n```","signature":"left: Relation, right: Relation","options":"","examples":["intersect(\n  restrict(suppliers, eq(:city, 'Paris')),\n  restrict(suppliers, gt(:status, 10)))"]},{"name":"join","synopsis":"Natural join","description":"Computes the relation resuting from joining tuples from `left` and `right`\nwhose respective projections on common attributes are equal.","notes":"Alf only support natural join for now. Other kinds of join can generally\nbe computed through longer expressions. For instance, joining on attributes\nwith different names requires some renaming first:\n\n```\n# suppose preferences has type Relation[supplier_id: String, ...]\n# suppose we want to join on suppliers.sid == preferences.supplier_id\njoin(suppliers, rename(preferences, :supplier_id => :sid))\n```\n\nCross joins can be computed through operands having no attribute in common.\nFor instance, all pairs of supplier and part identifiers can be computed\nas follows:\n\n```try\npairs = join(project(suppliers, [:sid]), project(parts, [:pid]))\n```\n\nNon equi-joins can be computed through a latter restriction. For instance,\nthe (supplier, part) pairs not located in the same city:\n\n```try\nps = project(rename(parts, :city => :part_city), [:pid, :part_city])\nss = project(rename(suppliers, :city => :supplier_city), [:sid, :supplier_city])\npairs = join(ps, ss)\nproject(restrict(pairs, neq(:part_city, :supplier_city)), [:sid, :pid])\n```\n\nAs obviously demonstrated by the example above, such query is rather\ncumbersome to write and verbous. Future versions of Alf will come with\nuseful shortcuts and new operators. In the mean time, don't forget that\ndefining your own shortcuts and operators is easy! Don't hesitate to\ncontribute them if of general purpose.\n\nLast, natural join tends to be error prone; in particular, you must take\ncare of common attributes of your design on which you do not want to join\n(such as `latest_change` and `deleted` fields and the like). Renamings and\nprojections are worth having at hand when joining.\n\nAlternatively, shortcuts can be considered. A (advanced) example below:\n\n```try\n# The following shortcut joins `left` and `right` on `wish` attributes\n# only. Other common attributes are simply projected away from `right`\n# before joining.\ndef join_on(left, right, wish)\n  commons = left.attr_list & right.attr_list\n  join(left, allbut(right, commons - wish))\nend\n\n# observe here how part names have been discarded to avoid joining them\n# with supplier names (empty result guaranteed)\njoin_on(suppliers, parts, [:city])\n```","signature":"left: Relation, right: Relation","options":"","examples":["join(suppliers, supplies)"]},{"name":"matching","synopsis":"Aka 'where exists'","description":"Computes a relation as a subset of `left` tuples for which at least one\n`right` tuple would join on common attributes.\n\nThis operator, also known as semi-join, can be explained through the\ndefinition below. As shown, it consists in joining `left` and `right`\nrelations and projecting the result back on `left` attributes.\n\n```try\ndef matching(left, right)\n  project(join(left, right), left.attr_list)\nend\nmatching(suppliers, supplies)\n```\n\nOr, in SQL terms:\n\n```\nSELECT left.* FROM left NATURAL JOIN right\n```\n\nThe synonym 'where exists' comes from the fact that, since right attributes\nare projected away, it may seem more intuitive to think about this operator\nas filtering tuples from left where _there exists_ some tuple at right that\n_would_ join. In SQL terms:\n\n```\nSELECT * FROM left WHERE EXISTS (SELECT * FROM right WHERE [join condition])\n```","notes":"As for (natural) `join`, you must take care of ensuring that the list of\ncommon attributes on which the matching applies corresponds to what you\nwant. Renamings and projections are worth having at hand when using\nmatching. Alternatively, shortcuts can be considered. A (advanced) example\nbelow:\n\n```try\n# Same as matching(left, right) except that only attributes in `wish`\n# are take into account in matching.\ndef matching_on(left, right, wish)\n  matching(left, project(right, wish))\nend\n\n# observe here how part names have been discarded to avoid matching them\n# with supplier names (empty result guaranteed)\nmatching_on(suppliers, parts, [:city])\n```","signature":"left: Relation, right: Relation","options":"","examples":["matching(suppliers, supplies)"]},{"name":"minus","synopsis":"Logical AND NOT","description":"Computes the relation as the set difference of `left` and `right`.\n\nThe `left` and `right` relations must be minus-compatible, which meaning\nthat they must have same heading (type inheritance is partly supported\nthrough ruby's own type system, so that the actual behavior is slighlty more\npermissive).","notes":"Unlike SQL, this operator ALWAYS remove duplicates. There is no way, in\nAlf, to compute _bags_ of tuples and therefore no way to express something\nsuch as SQL's EXCEPT ALL.\n\nIt is sometimes idiomatic in Alf to use `intersect` as a logical AND NOT, as\nillustrated below. So far, the optimizer/compiler is not smart enough to\ntranslate the former into the latter (which is likely to have a better query\nplan when using faithful SQL compilation and available SQL DBMSs). Any patch\nis welcome here too!\n\n```try\nminus(\n  restrict(suppliers, eq(:city, 'Paris')),\n  restrict(suppliers, gt(:status, 10)))\n```\n\nis equivalent to\n\n```try\nrestrict(suppliers, eq(:city, 'Paris') & !gt(:status, 10))\n```","signature":"left: Relation, right: Relation","options":"","examples":["minus(\n  restrict(suppliers, eq(:city, 'Paris')),\n  restrict(suppliers, gt(:status, 10)))"]},{"name":"not_matching","synopsis":"Aka 'where not exists'","description":"Computes a relation as a subset of `left` tuples for which no tuple from\n`right` would join on common attributes.\n\nThis operator is the inverse of `matching`, as shown by the definition\nbelow. It keeps all tuples from `left` but those that match a tuple from\n`right`.\n\n```try\ndef not_matching(left, right)\n  minus(left, matching(left, right))\nend\nnot_matching(suppliers, supplies)\n```\n\nThe synonym 'where not exists' comes from the fact that, since right\nattributes do not appear in the result, it may seem more intuitive to think\nabout this operator as filtering tuples from left where _there does not\nexist_ any tuple from right that _would_ join. In SQL terms:\n\n```\nSELECT * FROM left WHERE NOT EXISTS (SELECT * FROM right WHERE [join condition])\n```","notes":"As for join and matching, you must take care of ensuring that the list of\ncommon attributes on which the (not) matching applies corresponds to what\nyou want. Renamings and projections are worth having at hand.\nAlternatively, shortcuts can be considered (see `matching` and `join`).","signature":"left: Relation, right: Relation","options":"","examples":["not_matching(suppliers, supplies)"]},{"name":"page","synopsis":"Pagination","description":"Computes a relation by restricting the tuples of `operand` to those\nbelonging to the `nth` page (starting at 1). When `nth` is negative, returns\ntuples that belong to the `nth` page from the end (e.g., -1 is last page).\n\nFormally, the page is defined by those tuples whose ranking according to\n`order` is such that `(nth-1)*page_size <= rank < nth*page_size`. In other\nwords, this operator is almost equivalent to the following definition\n(ignoring negative page indexes for simplicity):\n\n```try\ndef page(operand, order, nth, page_size)\n  allbut(\n    restrict(\n      rank(operand, order, :rank),\n      lte((nth-1)*page_size, :rank) & lt(:rank, nth*page_size)),\n    [:rank])\nend\npage(suppliers, [:status, :sid], 1, 3)\n```\n\nAs of current Alf version, for this operator to be semantically sound and\ndeterministic, `order` MUST be a total order, that is, it must at least\ncover a candidate key. As of current Alf version, no error is raised if\nthis is not the case but that might change in future versions.","notes":"Contrary to the longer expression shown above, this operator compiles to\nSQL (rank does not, so far) at the cost of having to provide a total\norder.\n\nAs the result is a relation and relations are not ordered by definition,\nthe order in which tuples can be observed in the result (e.g. through\nexplicit tuple iteration, casting to an array, json encoding) is NOT\nguaranteed to follow `order`.","signature":"operand: Relation, ordering: Ordering, nth: Integer","options":"page_size: Integer","examples":["page(suppliers, [:status, :sid], 1, page_size: 3)","page(suppliers, [:status, :sid], -1, page_size: 3)"]},{"name":"project","synopsis":"Keeps only a subset of attributes.","description":"Computes the relation obtained by projecting tuples from `operand` on a\nsubset of their attributes.\n\nThis operator supports an ALL BUT variant, through the `allbut` option.\nWhen set to true, the operator _removes_ specified attributes instead of\nkeeping them. An `allbut` operator is also provided that has the same\neffect.","notes":"Unlike SQL, this operator ALWAYS remove duplicates. There is no way, in\nAlf, to compute _bags_ of tuples.","signature":"operand: Relation, attributes: AttrList","options":"allbut: Boolean","examples":["project(suppliers, [:city])","project(suppliers, [:city], allbut: true)"]},{"name":"rank","synopsis":"Tuple ranking","description":"Extends tuples from `operand` with a new attribute (`as`) capturing the\ntuple position with respect to `order`.\n\nThe ranking of a tuple `t` is more precisely defined as the number of tuples\nfrom `operand` that would come strictly before `t` if they were all ordered\naccording to `order`. 'Equal' tuples with respect to `order` are not counted\nin this ranking.\n\nThis means that, unless `order` is a total order, duplicate ranking may be\nobserved. In contrast, if `order` covers a candidate key then the ranking\nattribute (`as`) is unique, and therefore defines an additional candidate\nkey for the resulting relation.","notes":"Note that this operator does not compile to SQL so far. The `page` and\n`frame` operators provide useful alternatives when the aim is to compute\na subset of tuples based on a ranking.","signature":"operand: Relation, order: Ordering, as: AttrName","options":"","examples":["rank(suppliers, [:status], :ranking)","rank(suppliers, [:status, :sid], :ranking)"]},{"name":"rename","synopsis":"Rename attributes","description":"Computes the same relation as `operand` expect that some attributes have\nbeen renamed.","notes":"As of current version, renamings can only be expressed through a Hash\nmapping input to output attribute names.\n\nOther ways of specifying renamining will be added in future versions, such\nas prefixing, postfixing, renaming through a Proc, etc. Any patch towards\nthese improvements is welcome.","signature":"operand: Relation, renaming: Renaming","options":"","examples":["rename(suppliers, :sid => :supplier_id, :city => :lives_in)"]},{"name":"restrict","synopsis":"Predicate-based filtering","description":"Computes a relation as a subset of `operand` tuples for which a tuple\npredicate evaluates to TRUE.","notes":"As of current Alf version, native predicates (through ruby `Proc` objects)\ncannot be optimized nor compiled to SQL. The use of predicate factories\n(`eq`, `gt`, etc.) is strongly recommanded.","signature":"operand: Relation, predicate: Predicate","options":"","examples":["restrict(suppliers, city: 'Paris', status: 20)","restrict(suppliers, eq(city: 'Paris') & gt(:status, 20))","restrict(suppliers, ->(t){ t.city == 'Paris' and t.status > 20 })"]},{"name":"summarize","synopsis":"Aggregate and compute","description":"Computes the relation obtained by taking the projection of `operand`\non `by` attributes then extending each tuple `t` with the result of\naggregations defined by `aggs` on the tuples from `operand` matching `t`.\n\nIn SQL terms, `SELECT [by], [agg] FROM operand GROUP BY [by]`.","notes":"As of current Alf version, this operator cannot be translated to SQL code.\nThat means that all computations are done in ruby, which may seriously\nhurt performance.\n\nSimilarly, as `summarize` tends to be a showstopper during compilation, it\nis strongly recommanded to use it as high as possible in query expressions\ntrees so as to delegate the largest possible query parts to data engines.","signature":"operand: Relation, by: AttrList, aggs: Summarization","options":"allbut: Boolean","examples":["summarize(supplies, [:sid], total: sum(:qty))","summarize(supplies, [:sid], total: sum{|t| t.qty * 2 })","summarize(supplies, [:pid, :qty], {total: sum{|t| t.qty * 2 }}, allbut: true)"]},{"name":"ungroup","synopsis":"Inverse of group","description":"Computes the relation obtained by ungrouping a relation-valued attribute\n`rva`. Ungrouping `rva` leads as many tuples as in `rva`, each extended\nwith the other attributes of `operand`.\n\n`rva` must be a relation-valued attribute. It should not itself contain\nany attribute whose name clashes with an attribute of `operand`.","notes":"This operator does not compile to SQL so far. Contributions are welcome\nto provide it with a SQL compilation for SQL DBMSs that support this kind\nof feature (e.g. PostgreSQL with JSON data type)","signature":"operand: Relation, rva: AttrName","options":"","examples":["ungroup(group(suppliers, [:city], :suppliers, allbut: true), :suppliers)"]},{"name":"union","synopsis":"Logical OR","description":"Computes the relation as the set union of `left` and `right`.\n\nThe `left` and `right` relations must be union-compatible, meaning that they\nmust have same heading (type inheritance is partly supported through ruby's\nown type system, so that the actual behavior is slighlty more permissive).","notes":"Unlike SQL, this operator ALWAYS remove duplicates. There is no way, in\nAlf, to compute _bags_ of tuples and therefore no way to express something\nsuch as SQL's UNION ALL.\n\nThe optimizer is not smart enough so far to discover when operands are\nactually disjoint and duplicate removal not needed (e.g. the SQL compiler\nnever generates UNION ALL). Any patch improving this is welcome!\n\nSimilarly, it is sometimes idiomatic in Alf to use `union` as a logical OR,\nas illustrated below. So far, the optimizer/compiler is not smart enough to\ntranslate the former in the latter (which is likely to have a better query\nplan, especially when using faithful SQL compilation and usual SQL DBMSs).\nAny patch is welcome here too!\n\n```try\nunion(\n  restrict(suppliers, city: 'Paris'),\n  restrict(suppliers, city: 'London'))\n```\n\nis equivalent to\n\n```try\nrestrict(suppliers, eq(:city, 'Paris') | eq(:city, 'London'))\n```","signature":"left: Relation, right: Relation","options":"","examples":["union(project(suppliers, [:city]), project(parts, [:city]))"]},{"name":"unwrap","synopsis":"Inverse of wrap","description":"Computes the relation obtained by unwrapping a tuple-valued attribute `tva`.\nUnwrapping of `tva` on an input tuple `t` consists in removing `tva` from\n`t` and extending the result with `tva`'s own attributes:\n\n```\nTuple(x: 1, tva: Tuple(y: 2, z: 3)) -> Tuple(x: 1, y: 2, z: 3)\n```\n\n`tva` must be a tuple-valued attribute. It should not itself contain any\nattribute whose name clashes with an attribute of `operand`. In the examples\nabove, `tva` may not contain an attribute called `x`.","notes":"This operator does not compile to SQL so far. Contributions are welcome to\nprovide it with a SQL compilation for SQL DBMSs that support this kind of\nfeature (e.g. PostgreSQL with JSON data type)","signature":"operand: Relation, tva: AttrName","options":"","examples":["unwrap(wrap(suppliers, [:city, :status], :extra), :extra)"]},{"name":"wrap","synopsis":"Tuple-valued attribute","description":"Computes the relation obtained by removing `attributes` and replacing them\nby a single attribute (`as`). The latter is a tuple-valued attribute\nobtained by projecting the input tuple on `attributes`.\n\nThis operators supports an ALL BUT variant, through the `allbut` option.\nWhen set to true, the operator keeps specified attributes and wraps all the\nremaining ones as a tuple-valued attribute.","notes":"This operator does not compile to SQL so far. Contributions are welcome to\nprovide it with a SQL compilation for SQL DBMSs that support this kind of\nfeature (e.g. PostgreSQL with JSON data type)","signature":"operand: Relation, attributes: AttrList, as: AttrName","options":"allbut: Boolean","examples":["wrap(suppliers, [:city, :status], :extra)","wrap(suppliers, [:city, :status], :extra, allbut: true)"]}]
,"aggregators":[{"name":"avg","synopsis":"Average","description":"Aggregates through `v1 + v2 + ... + vn / n`.","notes":"This aggregate function should only be used with numeric types. As of\ncurrent Alf version, it does not aggregate empty sets correctly on\nnon-numeric data types.","signature":"expr: AttrName|(Tuple->Numeric)","options":"","examples":["avg(:qty)","avg{|t| t.qty * t.price }","avg(->(t){ t.qty * t.price })"]},{"name":"concat","synopsis":"String concatenation","description":"Concatenates string representations of input values.","notes":"This aggregate function can be applied to any data type, not only String\nattributes. Ruby's `to_s` will be used on values prior to concatenation.\n\nThe options are:\n\n* `before` starts the resulting string (defaults to '')\n* `after` ends the resulting string (defaults to '')\n* `between` is used between each value\n\nAs of current Alf version, the order in which the values are concatenated\nis not guaranteed. So far, this function is thus non-deterministic.","signature":"expr: AttrName|(Tuple->Numeric)","options":"before: String, between: String, after: String","examples":["concat(:name)","concat(:name, between: ', ')","concat(between: ', '){|t| t.name }","concat(->(t){ t.name.upcase }, between: ', ')"]},{"name":"count","synopsis":"Count","description":"Counts the number of input values.","notes":"","signature":"","options":"","examples":["count()"]},{"name":"max","synopsis":"Maximal value","description":"Returns the greatest of input values.","notes":"This aggregate function must only be used with comparable types. As of\ncurrent Alf version, it does not aggregate empty sets correctly.","signature":"expr: AttrName|(Tuple->Numeric)","options":"","examples":["max(:qty)","max{|t| t.qty * t.price }","max(->(t){ t.qty * t.price })"]},{"name":"min","synopsis":"Minimal value","description":"Returns the smallest of input values.","notes":"This aggregate function must only be used with comparable types. As of\ncurrent Alf version, it does not aggregate empty sets correctly.","signature":"expr: AttrName|(Tuple->Numeric)","options":"","examples":["min(:qty)","min{|t| t.qty * t.price }","min(->(t){ t.qty * t.price })"]},{"name":"stddev","synopsis":"Standard deviation","description":"Computes how much variation from the average exists.","notes":"This aggregate function should only be used with numeric types. As of\ncurrent Alf version, it does not aggregate empty sets correctly on\nnon-numeric data types.","signature":"expr: AttrName|(Tuple->Numeric)","options":"","examples":["stddev(:qty)","stddev{|t| t.qty * t.price }","stddev(->(t){ t.qty * t.price })"]},{"name":"sum","synopsis":"Arithmetic sum","description":"Computes `v1 + v2 + ... + vn`.","notes":"This aggregate function should only be used with numeric types. As of\ncurrent Alf version, it does not aggregate empty sets correctly on\nnon-numeric data types.","signature":"expr: AttrName|(Tuple->Numeric)","options":"","examples":["sum(:qty)","sum{|t| t.qty * t.price }","sum(->(t){ t.qty * t.price })"]},{"name":"variance","synopsis":"Variance","description":"Computes how far the set of input values is spread out.","notes":"This aggregate function should only be used with numeric types. As of\ncurrent Alf version, it does not aggregate empty sets correctly on\nnon-numeric data types.","signature":"expr: AttrName|(Tuple->Numeric)","options":"","examples":["variance(:qty)","variance{|t| t.qty * t.price }","variance(->(t){ t.qty * t.price })"]}]
,"examples":[{"source":"# Get all cities where either a supplier or a part is located.\nunion(\n  project(suppliers, [:city]),\n  project(parts, [:city]))\n"},{"source":"# Get the cities where at least one supplier is located.\nproject(suppliers, [:city])\n"},{"source":"# Get all suppliers, but their status and city.\nallbut(suppliers, [:status, :city])\n"},{"source":"# Get supplier names in upper case.\nproject(extend(suppliers, uppercase: ->(t){ t.name.upcase }), [:uppercase])\n"},{"source":"# Get the suppliers together with the parts they supply.\ngrouped = group(join(supplies, parts), [:sid], :supplied, allbut: true)\njoin(suppliers, grouped)\n"},{"source":"# Get all parts.\nparts\n"},{"source":"# Get suppliers who supply part P2.\nmatching(suppliers, restrict(supplies, pid: 'P2'))\n"},{"source":"# Get suppliers located in London or in Paris.\nrestrict(suppliers, eq(:city, 'London') | eq(:city, 'Paris'))\n"},{"source":"# Get suppliers located in London or in Paris.\nrestrict(suppliers, among(:city, ['London', 'Paris']))\n"},{"source":"# Get suppliers located in London or in Paris.\nmatching(suppliers, Relation(city: ['London', 'Paris']))\n"},{"source":"# Get suppliers located in London.\nrestrict(suppliers, city: 'London')\n"},{"source":"# Get suppliers in Paris with status strictly greater than 20.\nrestrict(suppliers, eq(:city, 'Paris') & gt(:status, 20))\n"},{"source":"# Get the suppliers, except those in London.\nminus(suppliers, restrict(suppliers, city: 'London'))\n"},{"source":"# Get the suppliers, except those in London.\nnot_matching(suppliers, Relation(city: 'London'))\n"},{"source":"# Show the suppliers, the parts and the supplies.\nextend(DEE,\n  suppliers: ->(t){ suppliers },\n  parts:     ->(t){ parts     },\n  supplies:  ->(t){ supplies  })\n"},{"source":"# Get the suppliers grouped by city.\ngroup(suppliers, [:city], :in_city, allbut: true)\n"},{"source":"# Get suppliers who do *not* supply part P2.\nnot_matching(suppliers, restrict(supplies, pid: 'P2'))\n"},{"source":"# Get suppliers who supply at least one red part.\nmatching(suppliers, matching(supplies, restrict(parts, color: 'Red')))\n"},{"source":"# Get suppliers who supply no part at all.\nnot_matching(suppliers, supplies)\n"},{"source":"# Get suppliers who have a 'a' in their name (case insensitive)\nrestrict(suppliers, ->(t){ t.name =~ /a/i })\n"},{"source":"# Get all suppliers.\nsuppliers\n"},{"source":"# Get the total supplied qty per supplier number.\nsummarize(supplies, [:sid], total: sum(:qty))\n"}]
}